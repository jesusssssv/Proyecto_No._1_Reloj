
AVRASM ver. 2.2.8  C:\Users\valen\OneDrive\Escritorio\Proyecto No. 1 - Reloj\Proyecto_No._1_Reloj\Proyecto No. 1 - Reloj (Código)\Proyecto No. 1 - Reloj (Código)\main.asm Tue Mar 18 09:44:26 2025

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328PBdef.inc'
C:\Users\valen\OneDrive\Escritorio\Proyecto No. 1 - Reloj\Proyecto_No._1_Reloj\Proyecto No. 1 - Reloj (Código)\Proyecto No. 1 - Reloj (Código)\main.asm(10): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328pbdef.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328PBdef.inc'
C:\Users\valen\OneDrive\Escritorio\Proyecto No. 1 - Reloj\Proyecto_No._1_Reloj\Proyecto No. 1 - Reloj (Código)\Proyecto No. 1 - Reloj (Código)\main.asm(10): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328pbdef.inc'
                                 
                                 ;***********************************************
                                 
                                 
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;*
                                 ;* Number            : AVR000
                                 ;* File Name         : m328PBdef.inc
                                 ;* Title             : Register/Bit Definitions for the ATmega328PB
                                 ;* Created           : 2021-07-13 10:39
                                 ;* Version           : 1.00
                                 ;* Support e-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328PB
                                 ;*
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal
                                 ;* SRAM is also defined
                                 ;*
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PBDEF_INC_
                                 #define _M328PBDEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device	ATmega328PB
                                 #pragma AVRPART ADMIN PART_NAME ATmega328PB
                                 .equ	SIGNATURE_000	= 0x1E
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x16
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED" are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	TWAMR1	= 0xDD ; MEMORY MAPPED
                                 .equ	TWCR1	= 0xDC ; MEMORY MAPPED
                                 .equ	TWDR1	= 0xDB ; MEMORY MAPPED
                                 .equ	TWAR1	= 0xDA ; MEMORY MAPPED
                                 .equ	TWSR1	= 0xD9 ; MEMORY MAPPED
                                 .equ	TWBR1	= 0xD8 ; MEMORY MAPPED
                                 .equ	UDR1	= 0xCE ; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xCD ; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xCC ; MEMORY MAPPED
                                 .equ	UCSR1D	= 0xCB ; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xCA ; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xC9 ; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xC8 ; MEMORY MAPPED
                                 .equ	UDR0	= 0xC6 ; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xC5 ; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xC4 ; MEMORY MAPPED
                                 .equ	UCSR0D	= 0xC3 ; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xC2 ; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xC1 ; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xC0 ; MEMORY MAPPED
                                 .equ	TWAMR0	= 0xBD ; MEMORY MAPPED
                                 .equ	TWCR0	= 0xBC ; MEMORY MAPPED
                                 .equ	TWDR0	= 0xBB ; MEMORY MAPPED
                                 .equ	TWAR0	= 0xBA ; MEMORY MAPPED
                                 .equ	TWSR0	= 0xB9 ; MEMORY MAPPED
                                 .equ	TWBR0	= 0xB8 ; MEMORY MAPPED
                                 .equ	ASSR	= 0xB6 ; MEMORY MAPPED
                                 .equ	OCR2B	= 0xB4 ; MEMORY MAPPED
                                 .equ	OCR2A	= 0xB3 ; MEMORY MAPPED
                                 .equ	TCNT2	= 0xB2 ; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xB1 ; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xB0 ; MEMORY MAPPED
                                 .equ	SPDR1	= 0xAE ; MEMORY MAPPED
                                 .equ	SPSR1	= 0xAD ; MEMORY MAPPED
                                 .equ	SPCR1	= 0xAC ; MEMORY MAPPED
                                 .equ	OCR4BH	= 0xAB ; MEMORY MAPPED
                                 .equ	OCR4BL	= 0xAA ; MEMORY MAPPED
                                 .equ	OCR4AH	= 0xA9 ; MEMORY MAPPED
                                 .equ	OCR4AL	= 0xA8 ; MEMORY MAPPED
                                 .equ	ICR4H	= 0xA7 ; MEMORY MAPPED
                                 .equ	ICR4L	= 0xA6 ; MEMORY MAPPED
                                 .equ	TCNT4H	= 0xA5 ; MEMORY MAPPED
                                 .equ	TCNT4L	= 0xA4 ; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xA2 ; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xA1 ; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xA0 ; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9B ; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9A ; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99 ; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98 ; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97 ; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96 ; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95 ; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94 ; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92 ; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91 ; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90 ; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8B ; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8A ; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89 ; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88 ; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87 ; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86 ; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85 ; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84 ; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82 ; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81 ; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80 ; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7F ; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7E ; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7C ; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7B ; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7A ; MEMORY MAPPED
                                 .equ	ADCH	= 0x79 ; MEMORY MAPPED
                                 .equ	ADCL	= 0x78 ; MEMORY MAPPED
                                 .equ	PCMSK3	= 0x73 ; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72 ; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71 ; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70 ; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6F ; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6E ; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6D ; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6C ; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6B ; MEMORY MAPPED
                                 .equ	EICRA	= 0x69 ; MEMORY MAPPED
                                 .equ	PCICR	= 0x68 ; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66 ; MEMORY MAPPED
                                 .equ	PRR1	= 0x65 ; MEMORY MAPPED
                                 .equ	PRR0	= 0x64 ; MEMORY MAPPED
                                 .equ	XFDCSR	= 0x62 ; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61 ; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60 ; MEMORY MAPPED
                                 .equ	SREG	= 0x3F ; 
                                 .equ	SPH	= 0x3E ; 
                                 .equ	SPL	= 0x3D ; 
                                 .equ	SPMCSR	= 0x37 ; 
                                 .equ	MCUCR	= 0x35 ; 
                                 .equ	MCUSR	= 0x34 ; 
                                 .equ	SMCR	= 0x33 ; 
                                 .equ	ACSRA	= 0x30 ; 
                                 .equ	ACSR	= 0x30 ; 
                                 .equ	ACSRB	= 0x2F ; 
                                 .equ	SPDR0	= 0x2E ; 
                                 .equ	SPSR0	= 0x2D ; 
                                 .equ	SPCR0	= 0x2C ; 
                                 .equ	GPIOR2	= 0x2B ; 
                                 .equ	GPIOR1	= 0x2A ; 
                                 .equ	OCR0B	= 0x28 ; 
                                 .equ	OCR0A	= 0x27 ; 
                                 .equ	TCNT0	= 0x26 ; 
                                 .equ	TCCR0B	= 0x25 ; 
                                 .equ	TCCR0A	= 0x24 ; 
                                 .equ	GTCCR	= 0x23 ; 
                                 .equ	EEARH	= 0x22 ; 
                                 .equ	EEARL	= 0x21 ; 
                                 .equ	EEDR	= 0x20 ; 
                                 .equ	EECR	= 0x1F ; 
                                 .equ	GPIOR0	= 0x1E ; 
                                 .equ	EIMSK	= 0x1D ; 
                                 .equ	EIFR	= 0x1C ; 
                                 .equ	PCIFR	= 0x1B ; 
                                 .equ	TIFR4	= 0x19 ; 
                                 .equ	TIFR3	= 0x18 ; 
                                 .equ	TIFR2	= 0x17 ; 
                                 .equ	TIFR1	= 0x16 ; 
                                 .equ	TIFR0	= 0x15 ; 
                                 .equ	PORTE	= 0x0E ; 
                                 .equ	DDRE	= 0x0D ; 
                                 .equ	PINE	= 0x0C ; 
                                 .equ	PORTD	= 0x0B ; 
                                 .equ	DDRD	= 0x0A ; 
                                 .equ	PIND	= 0x09 ; 
                                 .equ	PORTC	= 0x08 ; 
                                 .equ	DDRC	= 0x07 ; 
                                 .equ	PINC	= 0x06 ; 
                                 .equ	PORTB	= 0x05 ; 
                                 .equ	DDRB	= 0x04 ; 
                                 .equ	PINB	= 0x03 ; 
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** USART0 *****************
                                 ; UDR0 - USART I/O Data Register 0
                                 .equ	UDR00	= 0 ; USART I/O Data Register 0 Bit 0
                                 .equ	UDR01	= 1 ; USART I/O Data Register 0 Bit 1
                                 .equ	UDR02	= 2 ; USART I/O Data Register 0 Bit 2
                                 .equ	UDR03	= 3 ; USART I/O Data Register 0 Bit 3
                                 .equ	UDR04	= 4 ; USART I/O Data Register 0 Bit 4
                                 .equ	UDR05	= 5 ; USART I/O Data Register 0 Bit 5
                                 .equ	UDR06	= 6 ; USART I/O Data Register 0 Bit 6
                                 .equ	UDR07	= 7 ; USART I/O Data Register 0 Bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0 ; Multi-processor Communication Mode
                                 .equ	U2X0	= 1 ; Double the USART transmission speed
                                 .equ	UPE0	= 2 ; Parity Error
                                 .equ	DOR0	= 3 ; Data overRun
                                 .equ	FE0	= 4 ; Framing Error
                                 .equ	UDRE0	= 5 ; USART Data Register Empty
                                 .equ	TXC0	= 6 ; USART Transmitt Complete
                                 .equ	RXC0	= 7 ; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0 ; Transmit Data Bit 8
                                 .equ	RXB80	= 1 ; Receive Data Bit 8
                                 .equ	UCSZ02	= 2 ; Character Size - together with UCSZ0 in UCSR0C
                                 .equ	TXEN0	= 3 ; Transmitter Enable
                                 .equ	RXEN0	= 4 ; Receiver Enable
                                 .equ	UDRIE0	= 5 ; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6 ; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7 ; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0 ; Clock Polarity
                                 .equ	UCSZ00	= 1 ; Character Size - together with UCSZ2 in UCSR0B
                                 .equ	UCSZ01	= 2 ; Character Size - together with UCSZ2 in UCSR0B
                                 .equ	USBS0	= 3 ; Stop Bit Select
                                 .equ	UPM00	= 4 ; Parity Mode Bits
                                 .equ	UPM01	= 5 ; Parity Mode Bits
                                 .equ	UMSEL00	= 6 ; USART Mode Select
                                 .equ	UMSEL01	= 7 ; USART Mode Select
                                 
                                 ; UCSR0D - USART Control and Status Register D
                                 .equ	SFDE	= 5 ; Start frame detection enable
                                 .equ	RXS	= 6 ; USART RX Start
                                 .equ	RXSIE	= 7 ; USART RX Start Interrupt Enable
                                 
                                 ; UBRR0 - USART Baud Rate Register Bytes
                                 .equ	UBRR0H0	= 0 ; USART Baud Rate Register Bytes High Bit 8
                                 .equ	UBRR0H1	= 1 ; USART Baud Rate Register Bytes High Bit 9
                                 .equ	UBRR0H2	= 2 ; USART Baud Rate Register Bytes High Bit 10
                                 .equ	UBRR0H3	= 3 ; USART Baud Rate Register Bytes High Bit 11
                                 
                                 .equ	UBRR0L0	= 0 ; USART Baud Rate Register Bytes Low Bit 0
                                 .equ	UBRR0L1	= 1 ; USART Baud Rate Register Bytes Low Bit 1
                                 .equ	UBRR0L2	= 2 ; USART Baud Rate Register Bytes Low Bit 2
                                 .equ	UBRR0L3	= 3 ; USART Baud Rate Register Bytes Low Bit 3
                                 .equ	UBRR0L4	= 4 ; USART Baud Rate Register Bytes Low Bit 4
                                 .equ	UBRR0L5	= 5 ; USART Baud Rate Register Bytes Low Bit 5
                                 .equ	UBRR0L6	= 6 ; USART Baud Rate Register Bytes Low Bit 6
                                 .equ	UBRR0L7	= 7 ; USART Baud Rate Register Bytes Low Bit 7
                                 
                                 
                                 ; ***** USART1 *****************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0 ; USART I/O Data Register Bit 0
                                 .equ	UDR11	= 1 ; USART I/O Data Register Bit 1
                                 .equ	UDR12	= 2 ; USART I/O Data Register Bit 2
                                 .equ	UDR13	= 3 ; USART I/O Data Register Bit 3
                                 .equ	UDR14	= 4 ; USART I/O Data Register Bit 4
                                 .equ	UDR15	= 5 ; USART I/O Data Register Bit 5
                                 .equ	UDR16	= 6 ; USART I/O Data Register Bit 6
                                 .equ	UDR17	= 7 ; USART I/O Data Register Bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0 ; Multi-processor Communication Mode
                                 .equ	U2X1	= 1 ; Double the USART transmission speed
                                 .equ	UPE1	= 2 ; Parity Error
                                 .equ	DOR1	= 3 ; Data overRun
                                 .equ	FE1	= 4 ; Framing Error
                                 .equ	UDRE1	= 5 ; USART Data Register Empty
                                 .equ	TXC1	= 6 ; USART Transmitt Complete
                                 .equ	RXC1	= 7 ; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0 ; Transmit Data Bit 8
                                 .equ	RXB81	= 1 ; Receive Data Bit 8
                                 .equ	UCSZ12	= 2 ; Character Size - together with UCSZ0 in UCSR1C
                                 .equ	TXEN1	= 3 ; Transmitter Enable
                                 .equ	RXEN1	= 4 ; Receiver Enable
                                 .equ	UDRIE1	= 5 ; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6 ; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7 ; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0 ; Clock Polarity
                                 .equ	UCSZ10	= 1 ; Character Size - together with UCSZ12 in UCSR1B
                                 .equ	UCSZ11	= 2 ; Character Size - together with UCSZ12 in UCSR1B
                                 .equ	USBS1	= 3 ; Stop Bit Select
                                 .equ	UPM10	= 4 ; Parity Mode Bits
                                 .equ	UPM11	= 5 ; Parity Mode Bits
                                 .equ	UMSEL10	= 6 ; USART Mode Select
                                 .equ	UMSEL11	= 7 ; USART Mode Select
                                 
                                 ; UCSR1D - USART Control and Status Register D
                                 .equ	SFDE1	= 5 ; Start frame detection enable
                                 .equ	RXS1	= 6 ; USART RX Start
                                 .equ	RXSIE1	= 7 ; USART RX Start Interrupt Enable
                                 
                                 ; UBRR1 - USART Baud Rate Register Bytes
                                 .equ	UBRR1H0	= 0 ; USART Baud Rate Register Bytes High Bit 8
                                 .equ	UBRR1H1	= 1 ; USART Baud Rate Register Bytes High Bit 9
                                 .equ	UBRR1H2	= 2 ; USART Baud Rate Register Bytes High Bit 10
                                 .equ	UBRR1H3	= 3 ; USART Baud Rate Register Bytes High Bit 11
                                 
                                 .equ	UBRR1L0	= 0 ; USART Baud Rate Register Bytes Low Bit 0
                                 .equ	UBRR1L1	= 1 ; USART Baud Rate Register Bytes Low Bit 1
                                 .equ	UBRR1L2	= 2 ; USART Baud Rate Register Bytes Low Bit 2
                                 .equ	UBRR1L3	= 3 ; USART Baud Rate Register Bytes Low Bit 3
                                 .equ	UBRR1L4	= 4 ; USART Baud Rate Register Bytes Low Bit 4
                                 .equ	UBRR1L5	= 5 ; USART Baud Rate Register Bytes Low Bit 5
                                 .equ	UBRR1L6	= 6 ; USART Baud Rate Register Bytes Low Bit 6
                                 .equ	UBRR1L7	= 7 ; USART Baud Rate Register Bytes Low Bit 7
                                 
                                 
                                 ; ***** TWI0 *****************
                                 ; TWAMR0 - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1 ; 
                                 .equ	TWAM1	= 2 ; 
                                 .equ	TWAM2	= 3 ; 
                                 .equ	TWAM3	= 4 ; 
                                 .equ	TWAM4	= 5 ; 
                                 .equ	TWAM5	= 6 ; 
                                 .equ	TWAM6	= 7 ; 
                                 
                                 ; TWBR0 - TWI Bit Rate register
                                 .equ	TWBR00	= 0 ; TWI Bit Rate register Bit 0
                                 .equ	TWBR01	= 1 ; TWI Bit Rate register Bit 1
                                 .equ	TWBR02	= 2 ; TWI Bit Rate register Bit 2
                                 .equ	TWBR03	= 3 ; TWI Bit Rate register Bit 3
                                 .equ	TWBR04	= 4 ; TWI Bit Rate register Bit 4
                                 .equ	TWBR05	= 5 ; TWI Bit Rate register Bit 5
                                 .equ	TWBR06	= 6 ; TWI Bit Rate register Bit 6
                                 .equ	TWBR07	= 7 ; TWI Bit Rate register Bit 7
                                 
                                 ; TWCR0 - TWI Control Register
                                 .equ	TWIE	= 0 ; TWI Interrupt Enable
                                 .equ	TWEN	= 2 ; TWI Enable Bit
                                 .equ	TWWC	= 3 ; TWI Write Collition Flag
                                 .equ	TWSTO	= 4 ; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5 ; TWI Start Condition Bit
                                 .equ	TWEA	= 6 ; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7 ; TWI Interrupt Flag
                                 
                                 ; TWSR0 - TWI Status Register
                                 .equ	TWPS0	= 0 ; TWI Prescaler
                                 .equ	TWPS1	= 1 ; TWI Prescaler
                                 .equ	TWS3	= 3 ; TWI Status
                                 .equ	TWS4	= 4 ; TWI Status
                                 .equ	TWS5	= 5 ; TWI Status
                                 .equ	TWS6	= 6 ; TWI Status
                                 .equ	TWS7	= 7 ; TWI Status
                                 
                                 ; TWDR0 - TWI Data register
                                 .equ	TWDR00	= 0 ; TWI Data register Bit 0
                                 .equ	TWDR01	= 1 ; TWI Data register Bit 1
                                 .equ	TWDR02	= 2 ; TWI Data register Bit 2
                                 .equ	TWDR03	= 3 ; TWI Data register Bit 3
                                 .equ	TWDR04	= 4 ; TWI Data register Bit 4
                                 .equ	TWDR05	= 5 ; TWI Data register Bit 5
                                 .equ	TWDR06	= 6 ; TWI Data register Bit 6
                                 .equ	TWDR07	= 7 ; TWI Data register Bit 7
                                 
                                 ; TWAR0 - TWI (Slave) Address register
                                 .equ	TWGCE	= 0 ; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1 ; TWI (Slave) Address register Bits
                                 .equ	TWA1	= 2 ; TWI (Slave) Address register Bits
                                 .equ	TWA2	= 3 ; TWI (Slave) Address register Bits
                                 .equ	TWA3	= 4 ; TWI (Slave) Address register Bits
                                 .equ	TWA4	= 5 ; TWI (Slave) Address register Bits
                                 .equ	TWA5	= 6 ; TWI (Slave) Address register Bits
                                 .equ	TWA6	= 7 ; TWI (Slave) Address register Bits
                                 
                                 
                                 ; ***** TWI1 *****************
                                 ; TWAMR1 - TWI (Slave) Address Mask Register
                                 .equ	TWAM10	= 1 ; 
                                 .equ	TWAM11	= 2 ; 
                                 .equ	TWAM12	= 3 ; 
                                 .equ	TWAM13	= 4 ; 
                                 .equ	TWAM14	= 5 ; 
                                 .equ	TWAM15	= 6 ; 
                                 .equ	TWAM16	= 7 ; 
                                 
                                 ; TWBR1 - TWI Bit Rate register
                                 .equ	TWBR10	= 0 ; TWI Bit Rate register Bit 0
                                 .equ	TWBR11	= 1 ; TWI Bit Rate register Bit 1
                                 .equ	TWBR12	= 2 ; TWI Bit Rate register Bit 2
                                 .equ	TWBR13	= 3 ; TWI Bit Rate register Bit 3
                                 .equ	TWBR14	= 4 ; TWI Bit Rate register Bit 4
                                 .equ	TWBR15	= 5 ; TWI Bit Rate register Bit 5
                                 .equ	TWBR16	= 6 ; TWI Bit Rate register Bit 6
                                 .equ	TWBR17	= 7 ; TWI Bit Rate register Bit 7
                                 
                                 ; TWCR1 - TWI Control Register
                                 .equ	TWIE1	= 0 ; TWI Interrupt Enable
                                 .equ	TWEN1	= 2 ; TWI Enable Bit
                                 .equ	TWWC1	= 3 ; TWI Write Collition Flag
                                 .equ	TWSTO1	= 4 ; TWI Stop Condition Bit
                                 .equ	TWSTA1	= 5 ; TWI Start Condition Bit
                                 .equ	TWEA1	= 6 ; TWI Enable Acknowledge Bit
                                 .equ	TWINT1	= 7 ; TWI Interrupt Flag
                                 
                                 ; TWSR1 - TWI Status Register
                                 .equ	TWPS10	= 0 ; TWI Prescaler
                                 .equ	TWPS11	= 1 ; TWI Prescaler
                                 .equ	TWS13	= 3 ; TWI Status
                                 .equ	TWS14	= 4 ; TWI Status
                                 .equ	TWS15	= 5 ; TWI Status
                                 .equ	TWS16	= 6 ; TWI Status
                                 .equ	TWS17	= 7 ; TWI Status
                                 
                                 ; TWDR1 - TWI Data register
                                 .equ	TWDR10	= 0 ; TWI Data register Bit 0
                                 .equ	TWDR11	= 1 ; TWI Data register Bit 1
                                 .equ	TWDR12	= 2 ; TWI Data register Bit 2
                                 .equ	TWDR13	= 3 ; TWI Data register Bit 3
                                 .equ	TWDR14	= 4 ; TWI Data register Bit 4
                                 .equ	TWDR15	= 5 ; TWI Data register Bit 5
                                 .equ	TWDR16	= 6 ; TWI Data register Bit 6
                                 .equ	TWDR17	= 7 ; TWI Data register Bit 7
                                 
                                 ; TWAR1 - TWI (Slave) Address register
                                 .equ	TWAR10	= 0 ; TWI (Slave) Address register Bit 0
                                 .equ	TWAR11	= 1 ; TWI (Slave) Address register Bit 1
                                 .equ	TWAR12	= 2 ; TWI (Slave) Address register Bit 2
                                 .equ	TWAR13	= 3 ; TWI (Slave) Address register Bit 3
                                 .equ	TWAR14	= 4 ; TWI (Slave) Address register Bit 4
                                 .equ	TWAR15	= 5 ; TWI (Slave) Address register Bit 5
                                 .equ	TWAR16	= 6 ; TWI (Slave) Address register Bit 6
                                 .equ	TWAR17	= 7 ; TWI (Slave) Address register Bit 7
                                 
                                 
                                 ; ***** TC1 *****************
                                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 0 ; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1 ; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	OCIE1B	= 2 ; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	ICIE1	= 5 ; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 0 ; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1 ; Output Compare Flag 1A
                                 .equ	OCF1B	= 2 ; Output Compare Flag 1B
                                 .equ	ICF1	= 5 ; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0 ; Waveform Generation Mode
                                 .equ	WGM11	= 1 ; Waveform Generation Mode
                                 .equ	COM1B0	= 4 ; Compare Output Mode 1B, bits
                                 .equ	COM1B1	= 5 ; Compare Output Mode 1B, bits
                                 .equ	COM1A0	= 6 ; Compare Output Mode 1A, bits
                                 .equ	COM1A1	= 7 ; Compare Output Mode 1A, bits
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0 ; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1 ; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2 ; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3 ; Waveform Generation Mode
                                 .equ	WGM13	= 4 ; Waveform Generation Mode
                                 .equ	ICES1	= 6 ; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7 ; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1B	= 6 ; 
                                 .equ	FOC1A	= 7 ; 
                                 
                                 ; TCNT1 - Timer/Counter1 Bytes
                                 .equ	TCNT1H0	= 0 ; Timer/Counter1 Bytes High Bit 8
                                 .equ	TCNT1H1	= 1 ; Timer/Counter1 Bytes High Bit 9
                                 .equ	TCNT1H2	= 2 ; Timer/Counter1 Bytes High Bit 10
                                 .equ	TCNT1H3	= 3 ; Timer/Counter1 Bytes High Bit 11
                                 .equ	TCNT1H4	= 4 ; Timer/Counter1 Bytes High Bit 12
                                 .equ	TCNT1H5	= 5 ; Timer/Counter1 Bytes High Bit 13
                                 .equ	TCNT1H6	= 6 ; Timer/Counter1 Bytes High Bit 14
                                 .equ	TCNT1H7	= 7 ; Timer/Counter1 Bytes High Bit 15
                                 
                                 .equ	TCNT1L0	= 0 ; Timer/Counter1 Bytes Low Bit 0
                                 .equ	TCNT1L1	= 1 ; Timer/Counter1 Bytes Low Bit 1
                                 .equ	TCNT1L2	= 2 ; Timer/Counter1 Bytes Low Bit 2
                                 .equ	TCNT1L3	= 3 ; Timer/Counter1 Bytes Low Bit 3
                                 .equ	TCNT1L4	= 4 ; Timer/Counter1 Bytes Low Bit 4
                                 .equ	TCNT1L5	= 5 ; Timer/Counter1 Bytes Low Bit 5
                                 .equ	TCNT1L6	= 6 ; Timer/Counter1 Bytes Low Bit 6
                                 .equ	TCNT1L7	= 7 ; Timer/Counter1 Bytes Low Bit 7
                                 
                                 ; OCR1A - Timer/Counter1 Output Compare Register Bytes
                                 .equ	OCR1AH0	= 0 ; Timer/Counter1 Output Compare Register Bytes High Bit 8
                                 .equ	OCR1AH1	= 1 ; Timer/Counter1 Output Compare Register Bytes High Bit 9
                                 .equ	OCR1AH2	= 2 ; Timer/Counter1 Output Compare Register Bytes High Bit 10
                                 .equ	OCR1AH3	= 3 ; Timer/Counter1 Output Compare Register Bytes High Bit 11
                                 .equ	OCR1AH4	= 4 ; Timer/Counter1 Output Compare Register Bytes High Bit 12
                                 .equ	OCR1AH5	= 5 ; Timer/Counter1 Output Compare Register Bytes High Bit 13
                                 .equ	OCR1AH6	= 6 ; Timer/Counter1 Output Compare Register Bytes High Bit 14
                                 .equ	OCR1AH7	= 7 ; Timer/Counter1 Output Compare Register Bytes High Bit 15
                                 
                                 .equ	OCR1AL0	= 0 ; Timer/Counter1 Output Compare Register Bytes Low Bit 0
                                 .equ	OCR1AL1	= 1 ; Timer/Counter1 Output Compare Register Bytes Low Bit 1
                                 .equ	OCR1AL2	= 2 ; Timer/Counter1 Output Compare Register Bytes Low Bit 2
                                 .equ	OCR1AL3	= 3 ; Timer/Counter1 Output Compare Register Bytes Low Bit 3
                                 .equ	OCR1AL4	= 4 ; Timer/Counter1 Output Compare Register Bytes Low Bit 4
                                 .equ	OCR1AL5	= 5 ; Timer/Counter1 Output Compare Register Bytes Low Bit 5
                                 .equ	OCR1AL6	= 6 ; Timer/Counter1 Output Compare Register Bytes Low Bit 6
                                 .equ	OCR1AL7	= 7 ; Timer/Counter1 Output Compare Register Bytes Low Bit 7
                                 
                                 ; OCR1B - Timer/Counter1 Output Compare Register Bytes
                                 .equ	OCR1BH0	= 0 ; Timer/Counter1 Output Compare Register Bytes High Bit 8
                                 .equ	OCR1BH1	= 1 ; Timer/Counter1 Output Compare Register Bytes High Bit 9
                                 .equ	OCR1BH2	= 2 ; Timer/Counter1 Output Compare Register Bytes High Bit 10
                                 .equ	OCR1BH3	= 3 ; Timer/Counter1 Output Compare Register Bytes High Bit 11
                                 .equ	OCR1BH4	= 4 ; Timer/Counter1 Output Compare Register Bytes High Bit 12
                                 .equ	OCR1BH5	= 5 ; Timer/Counter1 Output Compare Register Bytes High Bit 13
                                 .equ	OCR1BH6	= 6 ; Timer/Counter1 Output Compare Register Bytes High Bit 14
                                 .equ	OCR1BH7	= 7 ; Timer/Counter1 Output Compare Register Bytes High Bit 15
                                 
                                 .equ	OCR1BL0	= 0 ; Timer/Counter1 Output Compare Register Bytes Low Bit 0
                                 .equ	OCR1BL1	= 1 ; Timer/Counter1 Output Compare Register Bytes Low Bit 1
                                 .equ	OCR1BL2	= 2 ; Timer/Counter1 Output Compare Register Bytes Low Bit 2
                                 .equ	OCR1BL3	= 3 ; Timer/Counter1 Output Compare Register Bytes Low Bit 3
                                 .equ	OCR1BL4	= 4 ; Timer/Counter1 Output Compare Register Bytes Low Bit 4
                                 .equ	OCR1BL5	= 5 ; Timer/Counter1 Output Compare Register Bytes Low Bit 5
                                 .equ	OCR1BL6	= 6 ; Timer/Counter1 Output Compare Register Bytes Low Bit 6
                                 .equ	OCR1BL7	= 7 ; Timer/Counter1 Output Compare Register Bytes Low Bit 7
                                 
                                 ; ICR1 - Timer/Counter1 Input Capture Register Bytes
                                 .equ	ICR1H0	= 0 ; Timer/Counter1 Input Capture Register Bytes High Bit 8
                                 .equ	ICR1H1	= 1 ; Timer/Counter1 Input Capture Register Bytes High Bit 9
                                 .equ	ICR1H2	= 2 ; Timer/Counter1 Input Capture Register Bytes High Bit 10
                                 .equ	ICR1H3	= 3 ; Timer/Counter1 Input Capture Register Bytes High Bit 11
                                 .equ	ICR1H4	= 4 ; Timer/Counter1 Input Capture Register Bytes High Bit 12
                                 .equ	ICR1H5	= 5 ; Timer/Counter1 Input Capture Register Bytes High Bit 13
                                 .equ	ICR1H6	= 6 ; Timer/Counter1 Input Capture Register Bytes High Bit 14
                                 .equ	ICR1H7	= 7 ; Timer/Counter1 Input Capture Register Bytes High Bit 15
                                 
                                 .equ	ICR1L0	= 0 ; Timer/Counter1 Input Capture Register Bytes Low Bit 0
                                 .equ	ICR1L1	= 1 ; Timer/Counter1 Input Capture Register Bytes Low Bit 1
                                 .equ	ICR1L2	= 2 ; Timer/Counter1 Input Capture Register Bytes Low Bit 2
                                 .equ	ICR1L3	= 3 ; Timer/Counter1 Input Capture Register Bytes Low Bit 3
                                 .equ	ICR1L4	= 4 ; Timer/Counter1 Input Capture Register Bytes Low Bit 4
                                 .equ	ICR1L5	= 5 ; Timer/Counter1 Input Capture Register Bytes Low Bit 5
                                 .equ	ICR1L6	= 6 ; Timer/Counter1 Input Capture Register Bytes Low Bit 6
                                 .equ	ICR1L7	= 7 ; Timer/Counter1 Input Capture Register Bytes Low Bit 7
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0 ; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	TSM	= 7 ; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TC3 *****************
                                 ; TIMSK3 - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE3	= 0 ; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1 ; Timer/Counter3 Output Compare Match A Interrupt Enable
                                 .equ	OCIE3B	= 2 ; Timer/Counter3 Output Compare Match B Interrupt Enable
                                 .equ	ICIE3	= 5 ; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0 ; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1 ; Output Compare Flag 3A
                                 .equ	OCF3B	= 2 ; Output Compare Flag 3B
                                 .equ	ICF3	= 5 ; Timer/Counter3 Input Capture Flag
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0 ; Waveform Genration Mode
                                 .equ	WGM31	= 1 ; Waveform Genration Mode
                                 .equ	COM3B0	= 4 ; Compare Output Mode bits
                                 .equ	COM3B1	= 5 ; Compare Output Mode bits
                                 .equ	COM3A0	= 6 ; Compare Output Mode bits
                                 .equ	COM3A1	= 7 ; Compare Output Mode bits
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0 ; Clock Select bits
                                 .equ	CS31	= 1 ; Clock Select bits
                                 .equ	CS32	= 2 ; Clock Select bits
                                 .equ	WGM32	= 3 ; Waveform Generation Mode bit 2
                                 .equ	WGM33	= 4 ; Waveform Generation Mode bit 3
                                 .equ	ICES3	= 6 ; Input Capture Edge Select
                                 .equ	ICNC3	= 7 ; Input Capture Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3B	= 6 ; Force Output Compare for Channel B
                                 .equ	FOC3A	= 7 ; Force Output Compare for Channel A
                                 
                                 ; TCNT3 - Timer/Counter3 Bytes
                                 .equ	TCNT3H0	= 0 ; Timer/Counter3 Bytes High Bit 8
                                 .equ	TCNT3H1	= 1 ; Timer/Counter3 Bytes High Bit 9
                                 .equ	TCNT3H2	= 2 ; Timer/Counter3 Bytes High Bit 10
                                 .equ	TCNT3H3	= 3 ; Timer/Counter3 Bytes High Bit 11
                                 .equ	TCNT3H4	= 4 ; Timer/Counter3 Bytes High Bit 12
                                 .equ	TCNT3H5	= 5 ; Timer/Counter3 Bytes High Bit 13
                                 .equ	TCNT3H6	= 6 ; Timer/Counter3 Bytes High Bit 14
                                 .equ	TCNT3H7	= 7 ; Timer/Counter3 Bytes High Bit 15
                                 
                                 .equ	TCNT3L0	= 0 ; Timer/Counter3 Bytes Low Bit 0
                                 .equ	TCNT3L1	= 1 ; Timer/Counter3 Bytes Low Bit 1
                                 .equ	TCNT3L2	= 2 ; Timer/Counter3 Bytes Low Bit 2
                                 .equ	TCNT3L3	= 3 ; Timer/Counter3 Bytes Low Bit 3
                                 .equ	TCNT3L4	= 4 ; Timer/Counter3 Bytes Low Bit 4
                                 .equ	TCNT3L5	= 5 ; Timer/Counter3 Bytes Low Bit 5
                                 .equ	TCNT3L6	= 6 ; Timer/Counter3 Bytes Low Bit 6
                                 .equ	TCNT3L7	= 7 ; Timer/Counter3 Bytes Low Bit 7
                                 
                                 ; OCR3A - Timer/Counter3 Output Compare Register Bytes
                                 .equ	OCR3AH0	= 0 ; Timer/Counter3 Output Compare Register Bytes High Bit 8
                                 .equ	OCR3AH1	= 1 ; Timer/Counter3 Output Compare Register Bytes High Bit 9
                                 .equ	OCR3AH2	= 2 ; Timer/Counter3 Output Compare Register Bytes High Bit 10
                                 .equ	OCR3AH3	= 3 ; Timer/Counter3 Output Compare Register Bytes High Bit 11
                                 .equ	OCR3AH4	= 4 ; Timer/Counter3 Output Compare Register Bytes High Bit 12
                                 .equ	OCR3AH5	= 5 ; Timer/Counter3 Output Compare Register Bytes High Bit 13
                                 .equ	OCR3AH6	= 6 ; Timer/Counter3 Output Compare Register Bytes High Bit 14
                                 .equ	OCR3AH7	= 7 ; Timer/Counter3 Output Compare Register Bytes High Bit 15
                                 
                                 .equ	OCR3AL0	= 0 ; Timer/Counter3 Output Compare Register Bytes Low Bit 0
                                 .equ	OCR3AL1	= 1 ; Timer/Counter3 Output Compare Register Bytes Low Bit 1
                                 .equ	OCR3AL2	= 2 ; Timer/Counter3 Output Compare Register Bytes Low Bit 2
                                 .equ	OCR3AL3	= 3 ; Timer/Counter3 Output Compare Register Bytes Low Bit 3
                                 .equ	OCR3AL4	= 4 ; Timer/Counter3 Output Compare Register Bytes Low Bit 4
                                 .equ	OCR3AL5	= 5 ; Timer/Counter3 Output Compare Register Bytes Low Bit 5
                                 .equ	OCR3AL6	= 6 ; Timer/Counter3 Output Compare Register Bytes Low Bit 6
                                 .equ	OCR3AL7	= 7 ; Timer/Counter3 Output Compare Register Bytes Low Bit 7
                                 
                                 ; OCR3B - Timer/Counter3 Output Compare Register Bytes
                                 .equ	OCR3BH0	= 0 ; Timer/Counter3 Output Compare Register Bytes High Bit 8
                                 .equ	OCR3BH1	= 1 ; Timer/Counter3 Output Compare Register Bytes High Bit 9
                                 .equ	OCR3BH2	= 2 ; Timer/Counter3 Output Compare Register Bytes High Bit 10
                                 .equ	OCR3BH3	= 3 ; Timer/Counter3 Output Compare Register Bytes High Bit 11
                                 .equ	OCR3BH4	= 4 ; Timer/Counter3 Output Compare Register Bytes High Bit 12
                                 .equ	OCR3BH5	= 5 ; Timer/Counter3 Output Compare Register Bytes High Bit 13
                                 .equ	OCR3BH6	= 6 ; Timer/Counter3 Output Compare Register Bytes High Bit 14
                                 .equ	OCR3BH7	= 7 ; Timer/Counter3 Output Compare Register Bytes High Bit 15
                                 
                                 .equ	OCR3BL0	= 0 ; Timer/Counter3 Output Compare Register Bytes Low Bit 0
                                 .equ	OCR3BL1	= 1 ; Timer/Counter3 Output Compare Register Bytes Low Bit 1
                                 .equ	OCR3BL2	= 2 ; Timer/Counter3 Output Compare Register Bytes Low Bit 2
                                 .equ	OCR3BL3	= 3 ; Timer/Counter3 Output Compare Register Bytes Low Bit 3
                                 .equ	OCR3BL4	= 4 ; Timer/Counter3 Output Compare Register Bytes Low Bit 4
                                 .equ	OCR3BL5	= 5 ; Timer/Counter3 Output Compare Register Bytes Low Bit 5
                                 .equ	OCR3BL6	= 6 ; Timer/Counter3 Output Compare Register Bytes Low Bit 6
                                 .equ	OCR3BL7	= 7 ; Timer/Counter3 Output Compare Register Bytes Low Bit 7
                                 
                                 ; ICR3 - Timer/Counter3 Input Capture Register Bytes
                                 .equ	ICR3H0	= 0 ; Timer/Counter3 Input Capture Register Bytes High Bit 8
                                 .equ	ICR3H1	= 1 ; Timer/Counter3 Input Capture Register Bytes High Bit 9
                                 .equ	ICR3H2	= 2 ; Timer/Counter3 Input Capture Register Bytes High Bit 10
                                 .equ	ICR3H3	= 3 ; Timer/Counter3 Input Capture Register Bytes High Bit 11
                                 .equ	ICR3H4	= 4 ; Timer/Counter3 Input Capture Register Bytes High Bit 12
                                 .equ	ICR3H5	= 5 ; Timer/Counter3 Input Capture Register Bytes High Bit 13
                                 .equ	ICR3H6	= 6 ; Timer/Counter3 Input Capture Register Bytes High Bit 14
                                 .equ	ICR3H7	= 7 ; Timer/Counter3 Input Capture Register Bytes High Bit 15
                                 
                                 .equ	ICR3L0	= 0 ; Timer/Counter3 Input Capture Register Bytes Low Bit 0
                                 .equ	ICR3L1	= 1 ; Timer/Counter3 Input Capture Register Bytes Low Bit 1
                                 .equ	ICR3L2	= 2 ; Timer/Counter3 Input Capture Register Bytes Low Bit 2
                                 .equ	ICR3L3	= 3 ; Timer/Counter3 Input Capture Register Bytes Low Bit 3
                                 .equ	ICR3L4	= 4 ; Timer/Counter3 Input Capture Register Bytes Low Bit 4
                                 .equ	ICR3L5	= 5 ; Timer/Counter3 Input Capture Register Bytes Low Bit 5
                                 .equ	ICR3L6	= 6 ; Timer/Counter3 Input Capture Register Bytes Low Bit 6
                                 .equ	ICR3L7	= 7 ; Timer/Counter3 Input Capture Register Bytes Low Bit 7
                                 
                                 
                                 ; ***** TC4 *****************
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 0 ; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4A	= 1 ; Timer/Counter4 Output Compare Match A Interrupt Enable
                                 .equ	OCIE4B	= 2 ; Timer/Counter4 Output Compare Match B Interrupt Enable
                                 .equ	ICIE4	= 5 ; Timer/Counter4 Input Capture Interrupt Enable
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 0 ; Timer/Counter4 Overflow Flag
                                 .equ	OCF4A	= 1 ; Output Compare Flag 4A
                                 .equ	OCF4B	= 2 ; Output Compare Flag 4B
                                 .equ	ICF4	= 5 ; Timer/Counter4 Input Capture Flag
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	WGM40	= 0 ; Waveform Generation Mode
                                 .equ	WGM41	= 1 ; Waveform Generation Mode
                                 .equ	COM4B0	= 4 ; Compare Output Mode bits
                                 .equ	COM4B1	= 5 ; Compare Output Mode bits
                                 .equ	COM4A0	= 6 ; Compare Output Mode bits
                                 .equ	COM4A1	= 7 ; Compare Output Mode bits
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0 ; Clock Select bits
                                 .equ	CS41	= 1 ; Clock Select bits
                                 .equ	CS42	= 2 ; Clock Select bits
                                 .equ	WGM42	= 3 ; Waveform Generation Mode bit 2
                                 .equ	WGM43	= 4 ; Waveform Generation Mode bit 3
                                 .equ	ICES4	= 6 ; Input Capture Edge Select
                                 .equ	ICNC4	= 7 ; Input Capture Noise Canceler
                                 
                                 ; TCCR4C - Timer/Counter4 Control Register C
                                 .equ	FOC4B	= 6 ; Force Output Compare for Channel B
                                 .equ	FOC4A	= 7 ; Force Output Compare for Channel A
                                 
                                 ; TCNT4 - Timer/Counter4 Bytes
                                 .equ	TCNT4H0	= 0 ; Timer/Counter4 Bytes High Bit 8
                                 .equ	TCNT4H1	= 1 ; Timer/Counter4 Bytes High Bit 9
                                 .equ	TCNT4H2	= 2 ; Timer/Counter4 Bytes High Bit 10
                                 .equ	TCNT4H3	= 3 ; Timer/Counter4 Bytes High Bit 11
                                 .equ	TCNT4H4	= 4 ; Timer/Counter4 Bytes High Bit 12
                                 .equ	TCNT4H5	= 5 ; Timer/Counter4 Bytes High Bit 13
                                 .equ	TCNT4H6	= 6 ; Timer/Counter4 Bytes High Bit 14
                                 .equ	TCNT4H7	= 7 ; Timer/Counter4 Bytes High Bit 15
                                 
                                 .equ	TCNT4L0	= 0 ; Timer/Counter4 Bytes Low Bit 0
                                 .equ	TCNT4L1	= 1 ; Timer/Counter4 Bytes Low Bit 1
                                 .equ	TCNT4L2	= 2 ; Timer/Counter4 Bytes Low Bit 2
                                 .equ	TCNT4L3	= 3 ; Timer/Counter4 Bytes Low Bit 3
                                 .equ	TCNT4L4	= 4 ; Timer/Counter4 Bytes Low Bit 4
                                 .equ	TCNT4L5	= 5 ; Timer/Counter4 Bytes Low Bit 5
                                 .equ	TCNT4L6	= 6 ; Timer/Counter4 Bytes Low Bit 6
                                 .equ	TCNT4L7	= 7 ; Timer/Counter4 Bytes Low Bit 7
                                 
                                 ; OCR4A - Timer/Counter4 Output Compare Register Bytes
                                 .equ	OCR4AH0	= 0 ; Timer/Counter4 Output Compare Register Bytes High Bit 8
                                 .equ	OCR4AH1	= 1 ; Timer/Counter4 Output Compare Register Bytes High Bit 9
                                 .equ	OCR4AH2	= 2 ; Timer/Counter4 Output Compare Register Bytes High Bit 10
                                 .equ	OCR4AH3	= 3 ; Timer/Counter4 Output Compare Register Bytes High Bit 11
                                 .equ	OCR4AH4	= 4 ; Timer/Counter4 Output Compare Register Bytes High Bit 12
                                 .equ	OCR4AH5	= 5 ; Timer/Counter4 Output Compare Register Bytes High Bit 13
                                 .equ	OCR4AH6	= 6 ; Timer/Counter4 Output Compare Register Bytes High Bit 14
                                 .equ	OCR4AH7	= 7 ; Timer/Counter4 Output Compare Register Bytes High Bit 15
                                 
                                 .equ	OCR4AL0	= 0 ; Timer/Counter4 Output Compare Register Bytes Low Bit 0
                                 .equ	OCR4AL1	= 1 ; Timer/Counter4 Output Compare Register Bytes Low Bit 1
                                 .equ	OCR4AL2	= 2 ; Timer/Counter4 Output Compare Register Bytes Low Bit 2
                                 .equ	OCR4AL3	= 3 ; Timer/Counter4 Output Compare Register Bytes Low Bit 3
                                 .equ	OCR4AL4	= 4 ; Timer/Counter4 Output Compare Register Bytes Low Bit 4
                                 .equ	OCR4AL5	= 5 ; Timer/Counter4 Output Compare Register Bytes Low Bit 5
                                 .equ	OCR4AL6	= 6 ; Timer/Counter4 Output Compare Register Bytes Low Bit 6
                                 .equ	OCR4AL7	= 7 ; Timer/Counter4 Output Compare Register Bytes Low Bit 7
                                 
                                 ; OCR4B - Timer/Counter4 Output Compare Register Bytes
                                 .equ	OCR4BH0	= 0 ; Timer/Counter4 Output Compare Register Bytes High Bit 8
                                 .equ	OCR4BH1	= 1 ; Timer/Counter4 Output Compare Register Bytes High Bit 9
                                 .equ	OCR4BH2	= 2 ; Timer/Counter4 Output Compare Register Bytes High Bit 10
                                 .equ	OCR4BH3	= 3 ; Timer/Counter4 Output Compare Register Bytes High Bit 11
                                 .equ	OCR4BH4	= 4 ; Timer/Counter4 Output Compare Register Bytes High Bit 12
                                 .equ	OCR4BH5	= 5 ; Timer/Counter4 Output Compare Register Bytes High Bit 13
                                 .equ	OCR4BH6	= 6 ; Timer/Counter4 Output Compare Register Bytes High Bit 14
                                 .equ	OCR4BH7	= 7 ; Timer/Counter4 Output Compare Register Bytes High Bit 15
                                 
                                 .equ	OCR4BL0	= 0 ; Timer/Counter4 Output Compare Register Bytes Low Bit 0
                                 .equ	OCR4BL1	= 1 ; Timer/Counter4 Output Compare Register Bytes Low Bit 1
                                 .equ	OCR4BL2	= 2 ; Timer/Counter4 Output Compare Register Bytes Low Bit 2
                                 .equ	OCR4BL3	= 3 ; Timer/Counter4 Output Compare Register Bytes Low Bit 3
                                 .equ	OCR4BL4	= 4 ; Timer/Counter4 Output Compare Register Bytes Low Bit 4
                                 .equ	OCR4BL5	= 5 ; Timer/Counter4 Output Compare Register Bytes Low Bit 5
                                 .equ	OCR4BL6	= 6 ; Timer/Counter4 Output Compare Register Bytes Low Bit 6
                                 .equ	OCR4BL7	= 7 ; Timer/Counter4 Output Compare Register Bytes Low Bit 7
                                 
                                 ; ICR4 - Timer/Counter4 Input Capture Register Bytes
                                 .equ	ICR4H0	= 0 ; Timer/Counter4 Input Capture Register Bytes High Bit 8
                                 .equ	ICR4H1	= 1 ; Timer/Counter4 Input Capture Register Bytes High Bit 9
                                 .equ	ICR4H2	= 2 ; Timer/Counter4 Input Capture Register Bytes High Bit 10
                                 .equ	ICR4H3	= 3 ; Timer/Counter4 Input Capture Register Bytes High Bit 11
                                 .equ	ICR4H4	= 4 ; Timer/Counter4 Input Capture Register Bytes High Bit 12
                                 .equ	ICR4H5	= 5 ; Timer/Counter4 Input Capture Register Bytes High Bit 13
                                 .equ	ICR4H6	= 6 ; Timer/Counter4 Input Capture Register Bytes High Bit 14
                                 .equ	ICR4H7	= 7 ; Timer/Counter4 Input Capture Register Bytes High Bit 15
                                 
                                 .equ	ICR4L0	= 0 ; Timer/Counter4 Input Capture Register Bytes Low Bit 0
                                 .equ	ICR4L1	= 1 ; Timer/Counter4 Input Capture Register Bytes Low Bit 1
                                 .equ	ICR4L2	= 2 ; Timer/Counter4 Input Capture Register Bytes Low Bit 2
                                 .equ	ICR4L3	= 3 ; Timer/Counter4 Input Capture Register Bytes Low Bit 3
                                 .equ	ICR4L4	= 4 ; Timer/Counter4 Input Capture Register Bytes Low Bit 4
                                 .equ	ICR4L5	= 5 ; Timer/Counter4 Input Capture Register Bytes Low Bit 5
                                 .equ	ICR4L6	= 6 ; Timer/Counter4 Input Capture Register Bytes Low Bit 6
                                 .equ	ICR4L7	= 7 ; Timer/Counter4 Input Capture Register Bytes Low Bit 7
                                 
                                 
                                 ; ***** TC2 *****************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0 ; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	OCIE2A	= 1 ; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2 ; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0 ; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1 ; Output Compare Flag 2A
                                 .equ	OCF2B	= 2 ; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0 ; Waveform Genration Mode
                                 .equ	WGM21	= 1 ; Waveform Genration Mode
                                 .equ	COM2B0	= 4 ; Compare Output Mode bits
                                 .equ	COM2B1	= 5 ; Compare Output Mode bits
                                 .equ	COM2A0	= 6 ; Compare Output Mode bits
                                 .equ	COM2A1	= 7 ; Compare Output Mode bits
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0 ; Clock Select bits
                                 .equ	CS21	= 1 ; Clock Select bits
                                 .equ	CS22	= 2 ; Clock Select bits
                                 .equ	WGM22	= 3 ; Waveform Generation Mode
                                 .equ	FOC2B	= 6 ; Force Output Compare B
                                 .equ	FOC2A	= 7 ; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT20	= 0 ; Timer/Counter2 Bit 0
                                 .equ	TCNT21	= 1 ; Timer/Counter2 Bit 1
                                 .equ	TCNT22	= 2 ; Timer/Counter2 Bit 2
                                 .equ	TCNT23	= 3 ; Timer/Counter2 Bit 3
                                 .equ	TCNT24	= 4 ; Timer/Counter2 Bit 4
                                 .equ	TCNT25	= 5 ; Timer/Counter2 Bit 5
                                 .equ	TCNT26	= 6 ; Timer/Counter2 Bit 6
                                 .equ	TCNT27	= 7 ; Timer/Counter2 Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B0	= 0 ; Timer/Counter2 Output Compare Register B Bit 0
                                 .equ	OCR2B1	= 1 ; Timer/Counter2 Output Compare Register B Bit 1
                                 .equ	OCR2B2	= 2 ; Timer/Counter2 Output Compare Register B Bit 2
                                 .equ	OCR2B3	= 3 ; Timer/Counter2 Output Compare Register B Bit 3
                                 .equ	OCR2B4	= 4 ; Timer/Counter2 Output Compare Register B Bit 4
                                 .equ	OCR2B5	= 5 ; Timer/Counter2 Output Compare Register B Bit 5
                                 .equ	OCR2B6	= 6 ; Timer/Counter2 Output Compare Register B Bit 6
                                 .equ	OCR2B7	= 7 ; Timer/Counter2 Output Compare Register B Bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A0	= 0 ; Timer/Counter2 Output Compare Register A Bit 0
                                 .equ	OCR2A1	= 1 ; Timer/Counter2 Output Compare Register A Bit 1
                                 .equ	OCR2A2	= 2 ; Timer/Counter2 Output Compare Register A Bit 2
                                 .equ	OCR2A3	= 3 ; Timer/Counter2 Output Compare Register A Bit 3
                                 .equ	OCR2A4	= 4 ; Timer/Counter2 Output Compare Register A Bit 4
                                 .equ	OCR2A5	= 5 ; Timer/Counter2 Output Compare Register A Bit 5
                                 .equ	OCR2A6	= 6 ; Timer/Counter2 Output Compare Register A Bit 6
                                 .equ	OCR2A7	= 7 ; Timer/Counter2 Output Compare Register A Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0 ; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1 ; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2 ; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3 ; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4 ; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5 ; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6 ; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1 ; Prescaler Reset Timer/Counter2
                                 
                                 
                                 ; ***** ADC *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0 ; Analog Channel Selection Bits
                                 .equ	MUX1	= 1 ; Analog Channel Selection Bits
                                 .equ	MUX2	= 2 ; Analog Channel Selection Bits
                                 .equ	MUX3	= 3 ; Analog Channel Selection Bits
                                 .equ	ADLAR	= 5 ; Left Adjust Result
                                 .equ	REFS0	= 6 ; Reference Selection Bits
                                 .equ	REFS1	= 7 ; Reference Selection Bits
                                 
                                 ; ADC - ADC Data Register Bytes
                                 .equ	ADCH0	= 0 ; ADC Data Register Bytes High Bit 8
                                 .equ	ADCH1	= 1 ; ADC Data Register Bytes High Bit 9
                                 .equ	ADCH2	= 2 ; ADC Data Register Bytes High Bit 10
                                 .equ	ADCH3	= 3 ; ADC Data Register Bytes High Bit 11
                                 .equ	ADCH4	= 4 ; ADC Data Register Bytes High Bit 12
                                 .equ	ADCH5	= 5 ; ADC Data Register Bytes High Bit 13
                                 .equ	ADCH6	= 6 ; ADC Data Register Bytes High Bit 14
                                 .equ	ADCH7	= 7 ; ADC Data Register Bytes High Bit 15
                                 
                                 .equ	ADCL0	= 0 ; ADC Data Register Bytes Low Bit 0
                                 .equ	ADCL1	= 1 ; ADC Data Register Bytes Low Bit 1
                                 .equ	ADCL2	= 2 ; ADC Data Register Bytes Low Bit 2
                                 .equ	ADCL3	= 3 ; ADC Data Register Bytes Low Bit 3
                                 .equ	ADCL4	= 4 ; ADC Data Register Bytes Low Bit 4
                                 .equ	ADCL5	= 5 ; ADC Data Register Bytes Low Bit 5
                                 .equ	ADCL6	= 6 ; ADC Data Register Bytes Low Bit 6
                                 .equ	ADCL7	= 7 ; ADC Data Register Bytes Low Bit 7
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0 ; ADC Prescaler Select Bits
                                 .equ	ADPS1	= 1 ; ADC Prescaler Select Bits
                                 .equ	ADPS2	= 2 ; ADC Prescaler Select Bits
                                 .equ	ADIE	= 3 ; ADC Interrupt Enable
                                 .equ	ADIF	= 4 ; ADC Interrupt Flag
                                 .equ	ADATE	= 5 ; ADC Auto Trigger Enable
                                 .equ	ADSC	= 6 ; ADC Start Conversion
                                 .equ	ADEN	= 7 ; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0 ; ADC Auto Trigger Source bits
                                 .equ	ADTS1	= 1 ; ADC Auto Trigger Source bits
                                 .equ	ADTS2	= 2 ; ADC Auto Trigger Source bits
                                 .equ	ACME	= 6 ; Analog Comparator Multiplexer Enable
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0 ; ADC Digital Input Disable
                                 .equ	ADC1D	= 1 ; ADC Digital Input Disable
                                 .equ	ADC2D	= 2 ; ADC Digital Input Disable
                                 .equ	ADC3D	= 3 ; ADC Digital Input Disable
                                 .equ	ADC4D	= 4 ; ADC Digital Input Disable
                                 .equ	ADC5D	= 5 ; ADC Digital Input Disable
                                 .equ	ADC6D	= 6 ; ADC Digital Input Disable
                                 .equ	ADC7D	= 7 ; ADC Digital Input Disable
                                 
                                 
                                 ; ***** AC *****************
                                 ; ACSRA - Analog Comparator Control And Status Register-A
                                 .equ	ACSRA0	= 0 ; Analog Comparator Control And Status Register-A Bit 0
                                 .equ	ACSRA1	= 1 ; Analog Comparator Control And Status Register-A Bit 1
                                 .equ	ACSRA2	= 2 ; Analog Comparator Control And Status Register-A Bit 2
                                 .equ	ACSRA3	= 3 ; Analog Comparator Control And Status Register-A Bit 3
                                 .equ	ACSRA4	= 4 ; Analog Comparator Control And Status Register-A Bit 4
                                 .equ	ACSRA5	= 5 ; Analog Comparator Control And Status Register-A Bit 5
                                 .equ	ACSRA6	= 6 ; Analog Comparator Control And Status Register-A Bit 6
                                 .equ	ACSRA7	= 7 ; Analog Comparator Control And Status Register-A Bit 7
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0 ; Analog Comparator Interrupt Mode Select bits
                                 .equ	ACIS1	= 1 ; Analog Comparator Interrupt Mode Select bits
                                 .equ	ACIC	= 2 ; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3 ; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4 ; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5 ; Analog Compare Output
                                 .equ	ACBG	= 6 ; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7 ; Analog Comparator Disable
                                 
                                 ; ACSRB - Analog Comparator Control And Status Register-B
                                 .equ	ACOE	= 0 ; Analog Comparator Output Enable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0 ; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1 ; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** PORTB *****************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0 ; Port B Data Register Bit 0
                                 .equ	PORTB1	= 1 ; Port B Data Register Bit 1
                                 .equ	PORTB2	= 2 ; Port B Data Register Bit 2
                                 .equ	PORTB3	= 3 ; Port B Data Register Bit 3
                                 .equ	PORTB4	= 4 ; Port B Data Register Bit 4
                                 .equ	PORTB5	= 5 ; Port B Data Register Bit 5
                                 .equ	PORTB6	= 6 ; Port B Data Register Bit 6
                                 .equ	PORTB7	= 7 ; Port B Data Register Bit 7
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDRB0	= 0 ; Port B Data Direction Register Bit 0
                                 .equ	DDRB1	= 1 ; Port B Data Direction Register Bit 1
                                 .equ	DDRB2	= 2 ; Port B Data Direction Register Bit 2
                                 .equ	DDRB3	= 3 ; Port B Data Direction Register Bit 3
                                 .equ	DDRB4	= 4 ; Port B Data Direction Register Bit 4
                                 .equ	DDRB5	= 5 ; Port B Data Direction Register Bit 5
                                 .equ	DDRB6	= 6 ; Port B Data Direction Register Bit 6
                                 .equ	DDRB7	= 7 ; Port B Data Direction Register Bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0 ; Port B Input Pins Bit 0
                                 .equ	PINB1	= 1 ; Port B Input Pins Bit 1
                                 .equ	PINB2	= 2 ; Port B Input Pins Bit 2
                                 .equ	PINB3	= 3 ; Port B Input Pins Bit 3
                                 .equ	PINB4	= 4 ; Port B Input Pins Bit 4
                                 .equ	PINB5	= 5 ; Port B Input Pins Bit 5
                                 .equ	PINB6	= 6 ; Port B Input Pins Bit 6
                                 .equ	PINB7	= 7 ; Port B Input Pins Bit 7
                                 
                                 
                                 ; ***** PORTC *****************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0 ; Port C Data Register Bit 0
                                 .equ	PORTC1	= 1 ; Port C Data Register Bit 1
                                 .equ	PORTC2	= 2 ; Port C Data Register Bit 2
                                 .equ	PORTC3	= 3 ; Port C Data Register Bit 3
                                 .equ	PORTC4	= 4 ; Port C Data Register Bit 4
                                 .equ	PORTC5	= 5 ; Port C Data Register Bit 5
                                 .equ	PORTC6	= 6 ; Port C Data Register Bit 6
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDRC0	= 0 ; Port C Data Direction Register Bit 0
                                 .equ	DDRC1	= 1 ; Port C Data Direction Register Bit 1
                                 .equ	DDRC2	= 2 ; Port C Data Direction Register Bit 2
                                 .equ	DDRC3	= 3 ; Port C Data Direction Register Bit 3
                                 .equ	DDRC4	= 4 ; Port C Data Direction Register Bit 4
                                 .equ	DDRC5	= 5 ; Port C Data Direction Register Bit 5
                                 .equ	DDRC6	= 6 ; Port C Data Direction Register Bit 6
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0 ; Port C Input Pins Bit 0
                                 .equ	PINC1	= 1 ; Port C Input Pins Bit 1
                                 .equ	PINC2	= 2 ; Port C Input Pins Bit 2
                                 .equ	PINC3	= 3 ; Port C Input Pins Bit 3
                                 .equ	PINC4	= 4 ; Port C Input Pins Bit 4
                                 .equ	PINC5	= 5 ; Port C Input Pins Bit 5
                                 .equ	PINC6	= 6 ; Port C Input Pins Bit 6
                                 
                                 
                                 ; ***** PORTD *****************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0 ; Port D Data Register Bit 0
                                 .equ	PORTD1	= 1 ; Port D Data Register Bit 1
                                 .equ	PORTD2	= 2 ; Port D Data Register Bit 2
                                 .equ	PORTD3	= 3 ; Port D Data Register Bit 3
                                 .equ	PORTD4	= 4 ; Port D Data Register Bit 4
                                 .equ	PORTD5	= 5 ; Port D Data Register Bit 5
                                 .equ	PORTD6	= 6 ; Port D Data Register Bit 6
                                 .equ	PORTD7	= 7 ; Port D Data Register Bit 7
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDRD0	= 0 ; Port D Data Direction Register Bit 0
                                 .equ	DDRD1	= 1 ; Port D Data Direction Register Bit 1
                                 .equ	DDRD2	= 2 ; Port D Data Direction Register Bit 2
                                 .equ	DDRD3	= 3 ; Port D Data Direction Register Bit 3
                                 .equ	DDRD4	= 4 ; Port D Data Direction Register Bit 4
                                 .equ	DDRD5	= 5 ; Port D Data Direction Register Bit 5
                                 .equ	DDRD6	= 6 ; Port D Data Direction Register Bit 6
                                 .equ	DDRD7	= 7 ; Port D Data Direction Register Bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0 ; Port D Input Pins Bit 0
                                 .equ	PIND1	= 1 ; Port D Input Pins Bit 1
                                 .equ	PIND2	= 2 ; Port D Input Pins Bit 2
                                 .equ	PIND3	= 3 ; Port D Input Pins Bit 3
                                 .equ	PIND4	= 4 ; Port D Input Pins Bit 4
                                 .equ	PIND5	= 5 ; Port D Input Pins Bit 5
                                 .equ	PIND6	= 6 ; Port D Input Pins Bit 6
                                 .equ	PIND7	= 7 ; Port D Input Pins Bit 7
                                 
                                 
                                 ; ***** PORTE *****************
                                 ; PORTE - Port E Data Register
                                 .equ	PORTE0	= 0 ; Port E Data Register Bit 0
                                 .equ	PORTE1	= 1 ; Port E Data Register Bit 1
                                 .equ	PORTE2	= 2 ; Port E Data Register Bit 2
                                 .equ	PORTE3	= 3 ; Port E Data Register Bit 3
                                 
                                 ; DDRE - Port E Data Direction Register
                                 .equ	DDRE0	= 0 ; Port E Data Direction Register Bit 0
                                 .equ	DDRE1	= 1 ; Port E Data Direction Register Bit 1
                                 .equ	DDRE2	= 2 ; Port E Data Direction Register Bit 2
                                 .equ	DDRE3	= 3 ; Port E Data Direction Register Bit 3
                                 
                                 ; PINE - Port E Input Pins
                                 .equ	PINE0	= 0 ; Port E Input Pins Bit 0
                                 .equ	PINE1	= 1 ; Port E Input Pins Bit 1
                                 .equ	PINE2	= 2 ; Port E Input Pins Bit 2
                                 .equ	PINE3	= 3 ; Port E Input Pins Bit 3
                                 
                                 
                                 ; ***** TC0 *****************
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B0	= 0 ; Timer/Counter0 Output Compare Register Bit 0
                                 .equ	OCR0B1	= 1 ; Timer/Counter0 Output Compare Register Bit 1
                                 .equ	OCR0B2	= 2 ; Timer/Counter0 Output Compare Register Bit 2
                                 .equ	OCR0B3	= 3 ; Timer/Counter0 Output Compare Register Bit 3
                                 .equ	OCR0B4	= 4 ; Timer/Counter0 Output Compare Register Bit 4
                                 .equ	OCR0B5	= 5 ; Timer/Counter0 Output Compare Register Bit 5
                                 .equ	OCR0B6	= 6 ; Timer/Counter0 Output Compare Register Bit 6
                                 .equ	OCR0B7	= 7 ; Timer/Counter0 Output Compare Register Bit 7
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A0	= 0 ; Timer/Counter0 Output Compare Register Bit 0
                                 .equ	OCR0A1	= 1 ; Timer/Counter0 Output Compare Register Bit 1
                                 .equ	OCR0A2	= 2 ; Timer/Counter0 Output Compare Register Bit 2
                                 .equ	OCR0A3	= 3 ; Timer/Counter0 Output Compare Register Bit 3
                                 .equ	OCR0A4	= 4 ; Timer/Counter0 Output Compare Register Bit 4
                                 .equ	OCR0A5	= 5 ; Timer/Counter0 Output Compare Register Bit 5
                                 .equ	OCR0A6	= 6 ; Timer/Counter0 Output Compare Register Bit 6
                                 .equ	OCR0A7	= 7 ; Timer/Counter0 Output Compare Register Bit 7
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT00	= 0 ; Timer/Counter0 Bit 0
                                 .equ	TCNT01	= 1 ; Timer/Counter0 Bit 1
                                 .equ	TCNT02	= 2 ; Timer/Counter0 Bit 2
                                 .equ	TCNT03	= 3 ; Timer/Counter0 Bit 3
                                 .equ	TCNT04	= 4 ; Timer/Counter0 Bit 4
                                 .equ	TCNT05	= 5 ; Timer/Counter0 Bit 5
                                 .equ	TCNT06	= 6 ; Timer/Counter0 Bit 6
                                 .equ	TCNT07	= 7 ; Timer/Counter0 Bit 7
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0 ; Clock Select
                                 .equ	CS01	= 1 ; Clock Select
                                 .equ	CS02	= 2 ; Clock Select
                                 .equ	WGM02	= 3 ; 
                                 .equ	FOC0B	= 6 ; Force Output Compare B
                                 .equ	FOC0A	= 7 ; Force Output Compare A
                                 
                                 ; TCCR0A - Timer/Counter Control Register A
                                 .equ	WGM00	= 0 ; Waveform Generation Mode
                                 .equ	WGM01	= 1 ; Waveform Generation Mode
                                 .equ	COM0B0	= 4 ; Compare Output Mode, Fast PWM
                                 .equ	COM0B1	= 5 ; Compare Output Mode, Fast PWM
                                 .equ	COM0A0	= 6 ; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7 ; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0 ; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1 ; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2 ; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0 ; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1 ; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2 ; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 
                                 
                                 ; ***** EXINT *****************
                                 ; EICRA - External Interrupt Control Register
                                 .equ	ISC00	= 0 ; External Interrupt Sense Control 0 Bits
                                 .equ	ISC01	= 1 ; External Interrupt Sense Control 0 Bits
                                 .equ	ISC10	= 2 ; External Interrupt Sense Control 1 Bits
                                 .equ	ISC11	= 3 ; External Interrupt Sense Control 1 Bits
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0 ; External Interrupt Request 1 Enable
                                 .equ	INT1	= 1 ; External Interrupt Request 1 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0 ; External Interrupt Flags
                                 .equ	INTF1	= 1 ; External Interrupt Flags
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0 ; Pin Change Interrupt Enables
                                 .equ	PCIE1	= 1 ; Pin Change Interrupt Enables
                                 .equ	PCIE2	= 2 ; Pin Change Interrupt Enables
                                 .equ	PCIE3	= 3 ; Pin Change Interrupt Enables
                                 
                                 ; PCMSK3 - Pin Change Mask Register 3
                                 .equ	PCINT24	= 0 ; Pin Change Enable Masks
                                 .equ	PCINT25	= 1 ; Pin Change Enable Masks
                                 .equ	PCINT26	= 2 ; Pin Change Enable Masks
                                 .equ	PCINT27	= 3 ; Pin Change Enable Masks
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0 ; Pin Change Enable Masks
                                 .equ	PCINT17	= 1 ; Pin Change Enable Masks
                                 .equ	PCINT18	= 2 ; Pin Change Enable Masks
                                 .equ	PCINT19	= 3 ; Pin Change Enable Masks
                                 .equ	PCINT20	= 4 ; Pin Change Enable Masks
                                 .equ	PCINT21	= 5 ; Pin Change Enable Masks
                                 .equ	PCINT22	= 6 ; Pin Change Enable Masks
                                 .equ	PCINT23	= 7 ; Pin Change Enable Masks
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0 ; Pin Change Enable Masks
                                 .equ	PCINT9	= 1 ; Pin Change Enable Masks
                                 .equ	PCINT10	= 2 ; Pin Change Enable Masks
                                 .equ	PCINT11	= 3 ; Pin Change Enable Masks
                                 .equ	PCINT12	= 4 ; Pin Change Enable Masks
                                 .equ	PCINT13	= 5 ; Pin Change Enable Masks
                                 .equ	PCINT14	= 6 ; Pin Change Enable Masks
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0 ; Pin Change Enable Masks
                                 .equ	PCINT1	= 1 ; Pin Change Enable Masks
                                 .equ	PCINT2	= 2 ; Pin Change Enable Masks
                                 .equ	PCINT3	= 3 ; Pin Change Enable Masks
                                 .equ	PCINT4	= 4 ; Pin Change Enable Masks
                                 .equ	PCINT5	= 5 ; Pin Change Enable Masks
                                 .equ	PCINT6	= 6 ; Pin Change Enable Masks
                                 .equ	PCINT7	= 7 ; Pin Change Enable Masks
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0 ; Pin Change Interrupt Flags
                                 .equ	PCIF1	= 1 ; Pin Change Interrupt Flags
                                 .equ	PCIF2	= 2 ; Pin Change Interrupt Flags
                                 .equ	PCIF3	= 3 ; Pin Change Interrupt Flags
                                 
                                 
                                 ; ***** SPI0 *****************
                                 ; SPDR0 - SPI Data Register
                                 .equ	SPDR00	= 0 ; SPI Data Register Bit 0
                                 .equ	SPDR01	= 1 ; SPI Data Register Bit 1
                                 .equ	SPDR02	= 2 ; SPI Data Register Bit 2
                                 .equ	SPDR03	= 3 ; SPI Data Register Bit 3
                                 .equ	SPDR04	= 4 ; SPI Data Register Bit 4
                                 .equ	SPDR05	= 5 ; SPI Data Register Bit 5
                                 .equ	SPDR06	= 6 ; SPI Data Register Bit 6
                                 .equ	SPDR07	= 7 ; SPI Data Register Bit 7
                                 
                                 ; SPSR0 - SPI Status Register
                                 .equ	SPI2X	= 0 ; Double SPI Speed Bit
                                 .equ	WCOL	= 6 ; Write Collision Flag
                                 .equ	SPIF	= 7 ; SPI Interrupt Flag
                                 
                                 ; SPCR0 - SPI Control Register
                                 .equ	SPR0	= 0 ; SPI Clock Rate Selects
                                 .equ	SPR1	= 1 ; SPI Clock Rate Selects
                                 .equ	CPHA	= 2 ; Clock Phase
                                 .equ	CPOL	= 3 ; Clock polarity
                                 .equ	MSTR	= 4 ; Master/Slave Select
                                 .equ	DORD	= 5 ; Data Order
                                 .equ	SPE	= 6 ; SPI Enable
                                 .equ	SPIE	= 7 ; SPI Interrupt Enable
                                 
                                 
                                 ; ***** SPI1 *****************
                                 ; SPDR1 - SPI Data Register
                                 .equ	SPDR10	= 0 ; SPI Data Register Bit 0
                                 .equ	SPDR11	= 1 ; SPI Data Register Bit 1
                                 .equ	SPDR12	= 2 ; SPI Data Register Bit 2
                                 .equ	SPDR13	= 3 ; SPI Data Register Bit 3
                                 .equ	SPDR14	= 4 ; SPI Data Register Bit 4
                                 .equ	SPDR15	= 5 ; SPI Data Register Bit 5
                                 .equ	SPDR16	= 6 ; SPI Data Register Bit 6
                                 .equ	SPDR17	= 7 ; SPI Data Register Bit 7
                                 
                                 ; SPSR1 - SPI Status Register
                                 .equ	SPI2X1	= 0 ; Double SPI Speed Bit
                                 .equ	WCOL1	= 6 ; Write Collision Flag
                                 .equ	SPIF1	= 7 ; SPI Interrupt Flag
                                 
                                 ; SPCR1 - SPI Control Register
                                 .equ	SPR10	= 0 ; SPI Clock Rate Selects
                                 .equ	SPR11	= 1 ; SPI Clock Rate Selects
                                 .equ	CPHA1	= 2 ; Clock Phase
                                 .equ	CPOL1	= 3 ; Clock polarity
                                 .equ	MSTR1	= 4 ; Master/Slave Select
                                 .equ	DORD1	= 5 ; Data Order
                                 .equ	SPE1	= 6 ; SPI Enable
                                 .equ	SPIE1	= 7 ; SPI Interrupt Enable
                                 
                                 
                                 ; ***** WDT *****************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDE	= 3 ; Watch Dog Enable
                                 .equ	WDCE	= 4 ; Watchdog Change Enable
                                 .equ	WDP0	= 0 ; Watchdog Timer Prescaler Bits
                                 .equ	WDP1	= 1 ; Watchdog Timer Prescaler Bits
                                 .equ	WDP2	= 2 ; Watchdog Timer Prescaler Bits
                                 .equ	WDP3	= 5 ; Watchdog Timer Prescaler Bits
                                 .equ	WDIE	= 6 ; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7 ; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** PTC *****************
                                 ; ***** CPU *****************
                                 ; PRR0 - Power Reduction Register 0
                                 .equ	PRADC	= 0 ; Power Reduction ADC
                                 .equ	PRUSART0	= 1 ; Power Reduction USART0
                                 .equ	PRSPI0	= 2 ; Power Reduction Serial Peripheral Interface 1
                                 .equ	PRTIM1	= 3 ; Power Reduction Timer/Counter1
                                 .equ	PRUSART1	= 4 ; Power Reduction USART1
                                 .equ	PRTIM0	= 5 ; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6 ; Power Reduction Timer/Counter2
                                 .equ	PRTWI0	= 7 ; Power Reduction TWI0
                                 
                                 ; PRR1 - Power Reduction Register 1
                                 .equ	PRTIM3	= 0 ; Power Reduction Timer/Counter3
                                 .equ	PRSPI1	= 2 ; Power Reduction Serial Peripheral Interface 1
                                 .equ	PRTIM4	= 3 ; Power Reduction Timer/Counter4
                                 .equ	PRPTC	= 4 ; Power Reduction Peripheral Touch Controller
                                 .equ	PRTWI1	= 5 ; Power Reduction TWI1
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	OSCCAL0	= 0 ; Oscillator Calibration
                                 .equ	OSCCAL1	= 1 ; Oscillator Calibration
                                 .equ	OSCCAL2	= 2 ; Oscillator Calibration
                                 .equ	OSCCAL3	= 3 ; Oscillator Calibration
                                 .equ	OSCCAL4	= 4 ; Oscillator Calibration
                                 .equ	OSCCAL5	= 5 ; Oscillator Calibration
                                 .equ	OSCCAL6	= 6 ; Oscillator Calibration
                                 .equ	OSCCAL7	= 7 ; Oscillator Calibration
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0 ; Clock Prescaler Select Bits
                                 .equ	CLKPS1	= 1 ; Clock Prescaler Select Bits
                                 .equ	CLKPS2	= 2 ; Clock Prescaler Select Bits
                                 .equ	CLKPS3	= 3 ; Clock Prescaler Select Bits
                                 .equ	CLKPCE	= 7 ; Clock Prescaler Change Enable
                                 
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0 ; Carry Flag
                                 .equ	SREG_Z	= 1 ; Zero Flag
                                 .equ	SREG_N	= 2 ; Negative Flag
                                 .equ	SREG_V	= 3 ; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4 ; Sign Bit
                                 .equ	SREG_H	= 5 ; Half Carry Flag
                                 .equ	SREG_T	= 6 ; Bit Copy Storage
                                 .equ	SREG_I	= 7 ; Global Interrupt Enable
                                 
                                 ; SP - Stack Pointer
                                 .equ	SPH0	= 0 ; Stack Pointer High Bit 8
                                 .equ	SPH1	= 1 ; Stack Pointer High Bit 9
                                 .equ	SPH2	= 2 ; Stack Pointer High Bit 10
                                 .equ	SPH3	= 3 ; Stack Pointer High Bit 11
                                 
                                 .equ	SPL0	= 0 ; Stack Pointer Low Bit 0
                                 .equ	SPL1	= 1 ; Stack Pointer Low Bit 1
                                 .equ	SPL2	= 2 ; Stack Pointer Low Bit 2
                                 .equ	SPL3	= 3 ; Stack Pointer Low Bit 3
                                 .equ	SPL4	= 4 ; Stack Pointer Low Bit 4
                                 .equ	SPL5	= 5 ; Stack Pointer Low Bit 5
                                 .equ	SPL6	= 6 ; Stack Pointer Low Bit 6
                                 .equ	SPL7	= 7 ; Stack Pointer Low Bit 7
                                 
                                 ; SPMCSR - Store Program Memory Control and Status Register
                                 .equ	SPMEN	= 0 ; Store Program Memory
                                 .equ	PGERS	= 1 ; Page Erase
                                 .equ	PGWRT	= 2 ; Page Write
                                 .equ	BLBSET	= 3 ; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4 ; Read-While-Write section read enable
                                 .equ	SIGRD	= 5 ; Signature Row Read
                                 .equ	RWWSB	= 6 ; Read-While-Write Section Busy
                                 .equ	SPMIE	= 7 ; SPM Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0 ; 
                                 .equ	IVSEL	= 1 ; 
                                 .equ	PUD	= 4 ; 
                                 .equ	BODSE	= 5 ; BOD Sleep Enable
                                 .equ	BODS	= 6 ; BOD Sleep
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0 ; Power-on reset flag
                                 .equ	EXTRF	= 1 ; External Reset Flag
                                 .equ	BORF	= 2 ; Brown-out Reset Flag
                                 .equ	WDRF	= 3 ; Watchdog Reset Flag
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0 ; Sleep Enable
                                 .equ	SM0	= 1 ; Sleep Mode Select Bits
                                 .equ	SM1	= 2 ; Sleep Mode Select Bits
                                 .equ	SM2	= 3 ; Sleep Mode Select Bits
                                 
                                 ; GPIOR2 - General Purpose I/O Register 2
                                 .equ	GPIOR20	= 0 ; General Purpose I/O Register 2 Bit 0
                                 .equ	GPIOR21	= 1 ; General Purpose I/O Register 2 Bit 1
                                 .equ	GPIOR22	= 2 ; General Purpose I/O Register 2 Bit 2
                                 .equ	GPIOR23	= 3 ; General Purpose I/O Register 2 Bit 3
                                 .equ	GPIOR24	= 4 ; General Purpose I/O Register 2 Bit 4
                                 .equ	GPIOR25	= 5 ; General Purpose I/O Register 2 Bit 5
                                 .equ	GPIOR26	= 6 ; General Purpose I/O Register 2 Bit 6
                                 .equ	GPIOR27	= 7 ; General Purpose I/O Register 2 Bit 7
                                 
                                 ; GPIOR1 - General Purpose I/O Register 1
                                 .equ	GPIOR10	= 0 ; General Purpose I/O Register 1 Bit 0
                                 .equ	GPIOR11	= 1 ; General Purpose I/O Register 1 Bit 1
                                 .equ	GPIOR12	= 2 ; General Purpose I/O Register 1 Bit 2
                                 .equ	GPIOR13	= 3 ; General Purpose I/O Register 1 Bit 3
                                 .equ	GPIOR14	= 4 ; General Purpose I/O Register 1 Bit 4
                                 .equ	GPIOR15	= 5 ; General Purpose I/O Register 1 Bit 5
                                 .equ	GPIOR16	= 6 ; General Purpose I/O Register 1 Bit 6
                                 .equ	GPIOR17	= 7 ; General Purpose I/O Register 1 Bit 7
                                 
                                 ; GPIOR0 - General Purpose I/O Register 0
                                 .equ	GPIOR00	= 0 ; General Purpose I/O Register 0 Bit 0
                                 .equ	GPIOR01	= 1 ; General Purpose I/O Register 0 Bit 1
                                 .equ	GPIOR02	= 2 ; General Purpose I/O Register 0 Bit 2
                                 .equ	GPIOR03	= 3 ; General Purpose I/O Register 0 Bit 3
                                 .equ	GPIOR04	= 4 ; General Purpose I/O Register 0 Bit 4
                                 .equ	GPIOR05	= 5 ; General Purpose I/O Register 0 Bit 5
                                 .equ	GPIOR06	= 6 ; General Purpose I/O Register 0 Bit 6
                                 .equ	GPIOR07	= 7 ; General Purpose I/O Register 0 Bit 7
                                 
                                 
                                 ; ***** EEPROM *****************
                                 ; EEAR - EEPROM Address Register Bytes
                                 .equ	EEARH0	= 0 ; EEPROM Address Register Bytes High Bit 8
                                 .equ	EEARH1	= 1 ; EEPROM Address Register Bytes High Bit 9
                                 
                                 .equ	EEARL0	= 0 ; EEPROM Address Register Bytes Low Bit 0
                                 .equ	EEARL1	= 1 ; EEPROM Address Register Bytes Low Bit 1
                                 .equ	EEARL2	= 2 ; EEPROM Address Register Bytes Low Bit 2
                                 .equ	EEARL3	= 3 ; EEPROM Address Register Bytes Low Bit 3
                                 .equ	EEARL4	= 4 ; EEPROM Address Register Bytes Low Bit 4
                                 .equ	EEARL5	= 5 ; EEPROM Address Register Bytes Low Bit 5
                                 .equ	EEARL6	= 6 ; EEPROM Address Register Bytes Low Bit 6
                                 .equ	EEARL7	= 7 ; EEPROM Address Register Bytes Low Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0 ; EEPROM Data Register Bit 0
                                 .equ	EEDR1	= 1 ; EEPROM Data Register Bit 1
                                 .equ	EEDR2	= 2 ; EEPROM Data Register Bit 2
                                 .equ	EEDR3	= 3 ; EEPROM Data Register Bit 3
                                 .equ	EEDR4	= 4 ; EEPROM Data Register Bit 4
                                 .equ	EEDR5	= 5 ; EEPROM Data Register Bit 5
                                 .equ	EEDR6	= 6 ; EEPROM Data Register Bit 6
                                 .equ	EEDR7	= 7 ; EEPROM Data Register Bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0 ; EEPROM Read Enable
                                 .equ	EEPE	= 1 ; EEPROM Write Enable
                                 .equ	EEMPE	= 2 ; EEPROM Master Write Enable
                                 .equ	EERIE	= 3 ; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4 ; EEPROM Programming Mode Bits
                                 .equ	EEPM1	= 5 ; EEPROM Programming Mode Bits
                                 
                                 
                                 ; ***** FUSE *****************
                                 ; EXTENDED - 
                                 .equ	BODLEVEL0	= 0 ; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1 ; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2 ; Brown-out Detector trigger level
                                 .equ	CFD	= 3 ; Clock Failure Detection
                                 
                                 ; HIGH - 
                                 .equ	BOOTRST	= 0 ; Boot Reset vector Enabled
                                 .equ	BOOTSZ0	= 1 ; Select boot size
                                 .equ	BOOTSZ1	= 2 ; Select boot size
                                 .equ	EESAVE	= 3 ; Preserve EEPROM through the Chip Erase cycle
                                 .equ	WDTON	= 4 ; Watch-dog Timer always on
                                 .equ	SPIEN	= 5 ; Serial program downloading (SPI) enabled
                                 .equ	DWEN	= 6 ; Debug Wire enable
                                 .equ	RSTDISBL	= 7 ; Reset Disabled (Enable PC6 as i/o pin)
                                 
                                 ; LOW - 
                                 .equ	SUT_CKSEL0	= 0 ; Select Clock Source
                                 .equ	SUT_CKSEL1	= 1 ; Select Clock Source
                                 .equ	SUT_CKSEL2	= 2 ; Select Clock Source
                                 .equ	SUT_CKSEL3	= 3 ; Select Clock Source
                                 .equ	SUT_CKSEL4	= 4 ; Select Clock Source
                                 .equ	SUT_CKSEL5	= 5 ; Select Clock Source
                                 .equ	CKOUT	= 6 ; Clock output on PORTB0
                                 .equ	CKDIV8	= 7 ; Divide clock by 8 internally
                                 
                                 
                                 ; ***** LOCKBIT *****************
                                 ; LOCKBIT - 
                                 .equ	LB1	= 0 ; Memory Lock
                                 .equ	LB2	= 1 ; Memory Lock
                                 .equ	BLB01	= 2 ; Boot Loader Protection Mode
                                 .equ	BLB02	= 3 ; Boot Loader Protection Mode
                                 .equ	BLB11	= 4 ; Boot Loader Protection Mode
                                 .equ	BLB12	= 5 ; Boot Loader Protection Mode
                                 
                                 
                                 ; ***** CFD *****************
                                 ; XFDCSR - XOSC Failure Detection Control and Status Register
                                 .equ	XFDIE	= 0 ; Failure Detection Interrupt Enable
                                 .equ	XFDIF	= 1 ; Failure Detection Interrupt Flag
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHSTART	= 0x0000 ; Note: Word address
                                 .equ	FLASHEND	= 0x3FFF ; Note: Word address
                                 .equ	FLASHPAGESIZE	= 0x0040 ; Note: Size in words
                                 
                                 .equ	BOOTSECTION1START	= 0x3F00 ; Note: Word address
                                 .equ	BOOTSECTION1END	= 0x3FFF ; Note: Word address
                                 .equ	BOOTSECTION1PAGESIZE	= 0x0040 ; Note: Size in words
                                 
                                 .equ	BOOTSECTION2START	= 0x3E00 ; Note: Word address
                                 .equ	BOOTSECTION2END	= 0x3FFF ; Note: Word address
                                 .equ	BOOTSECTION2PAGESIZE	= 0x0040 ; Note: Size in words
                                 
                                 .equ	BOOTSECTION3START	= 0x3C00 ; Note: Word address
                                 .equ	BOOTSECTION3END	= 0x3FFF ; Note: Word address
                                 .equ	BOOTSECTION3PAGESIZE	= 0x0040 ; Note: Size in words
                                 
                                 .equ	BOOTSECTION4START	= 0x3800 ; Note: Word address
                                 .equ	BOOTSECTION4END	= 0x3FFF ; Note: Word address
                                 .equ	BOOTSECTION4PAGESIZE	= 0x0040 ; Note: Size in words
                                 
                                 .equ	IOEND	= 0x00FF
                                 
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 2048
                                 .equ	RAMEND	= 0x08FF
                                 
                                 .equ	E2END	= 0x03FF
                                 .equ	EEPROMEND	= 0x03FF
                                 .equ	EEADRBITS	= 10
                                 
                                 .equ	XRAMEND	= 0x0000
                                 
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	PAGESIZE	= 0x0040 ; Note: Size in words
                                 
                                 .equ	FIRSTBOOTSTART	= 0x3F00 ; Note: Word address
                                 .equ	FIRSTBOOTPAGESIZE	= 0x0040 ; Note: Size in words
                                 .equ	FIRSTBOOTEND	= 0x0000 ; Note: Word address
                                 
                                 .equ	SECONDBOOTSTART	= 0x3E00 ; Note: Word address
                                 .equ	SECONDBOOTPAGESIZE	= 0x0040 ; Note: Size in words
                                 .equ	SECONDBOOTEND	= 0x0000 ; Note: Word address
                                 
                                 .equ	THIRDBOOTSTART	= 0x3C00 ; Note: Word address
                                 .equ	THIRDBOOTPAGESIZE	= 0x0040 ; Note: Size in words
                                 .equ	THIRDBOOTEND	= 0x0000 ; Note: Word address
                                 
                                 .equ	FOURTHBOOTSTART	= 0x3800 ; Note: Word address
                                 .equ	FOURTHBOOTPAGESIZE	= 0x0040 ; Note: Size in words
                                 .equ	FOURTHBOOTEND	= 0x0000 ; Note: Word address
                                 
                                 .equ	 SMALLBOOTSTART	= FIRSTBOOTSTART ;
                                 .equ	 LARGEBOOTSTART	= FOURTHBOOTSTART ;
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	 = 0x0002 ; External Interrupt Request 0
                                 .equ	INT1addr	 = 0x0004 ; External Interrupt Request 1
                                 .equ	PCINT0addr	 = 0x0006 ; Pin Change Interrupt Request 0
                                 .equ	PCINT1addr	 = 0x0008 ; Pin Change Interrupt Request 1
                                 .equ	PCINT2addr	 = 0x000A ; Pin Change Interrupt Request 2
                                 .equ	WDTaddr	 = 0x000C ; Watchdog Time-out Interrupt
                                 .equ	TIMER2_COMPAaddr	 = 0x000E ; Timer/Counter2 Compare Match A
                                 .equ	TIMER2_COMPBaddr	 = 0x0010 ; Timer/Counter2 Compare Match B
                                 .equ	TIMER2_OVFaddr	 = 0x0012 ; Timer/Counter2 Overflow
                                 .equ	TIMER1_CAPTaddr	 = 0x0014 ; Timer/Counter1 Capture Event
                                 .equ	TIMER1_COMPAaddr	 = 0x0016 ; Timer/Counter1 Compare Match A
                                 .equ	TIMER1_COMPBaddr	 = 0x0018 ; Timer/Counter1 Compare Match B
                                 .equ	TIMER1_OVFaddr	 = 0x001A ; Timer/Counter1 Overflow
                                 .equ	TIMER0_COMPAaddr	 = 0x001C ; TimerCounter0 Compare Match A
                                 .equ	TIMER0_COMPBaddr	 = 0x001E ; TimerCounter0 Compare Match B
                                 .equ	TIMER0_OVFaddr	 = 0x0020 ; Timer/Couner0 Overflow
                                 .equ	SPI0_STCaddr	 = 0x0022 ; SPI Serial Transfer Complete
                                 .equ	USART0_RXaddr	 = 0x0024 ; USART0 Rx Complete
                                 .equ	USART0_UDREaddr	 = 0x0026 ; USART0, Data Register Empty
                                 .equ	USART0_TXaddr	 = 0x0028 ; USART0 Tx Complete
                                 .equ	ADCaddr	 = 0x002A ; ADC Conversion Complete
                                 .equ	EE_READYaddr	 = 0x002C ; EEPROM Ready
                                 .equ	ANALOG_COMPaddr	 = 0x002E ; Analog Comparator
                                 .equ	TWI0addr	 = 0x0030 ; Two-wire Serial Interface
                                 .equ	SPM_Readyaddr	 = 0x0032 ; Store Program Memory Read
                                 .equ	USART0_STARTaddr	 = 0x0034 ; USART0 Start frame detection
                                 .equ	PCINT3addr	 = 0x0036 ; Pin Change Interrupt Request 3
                                 .equ	USART1_RXaddr	 = 0x0038 ; USART1 Rx Complete
                                 .equ	USART1_UDREaddr	 = 0x003A ; USART1, Data Register Empty
                                 .equ	USART1_TXaddr	 = 0x003C ; USART1 Tx Complete
                                 .equ	USART1_STARTaddr	 = 0x003E ; USART1 Start frame detection
                                 .equ	TIMER3_CAPTaddr	 = 0x0040 ; Timer/Counter3 Capture Event
                                 .equ	TIMER3_COMPAaddr	 = 0x0042 ; Timer/Counter3 Compare Match A
                                 .equ	TIMER3_COMPBaddr	 = 0x0044 ; Timer/Counter3 Compare Match B
                                 .equ	TIMER3_OVFaddr	 = 0x0046 ; Timer/Counter3 Overflow
                                 .equ	CFDaddr	 = 0x0048 ; Clock failure detection interrupt
                                 .equ	PTC_EOCaddr	 = 0x004A ; PTC End of conversion
                                 .equ	PTC_WCOMPaddr	 = 0x004C ; PTC Window comparator mode
                                 .equ	SPI1_STCaddr	 = 0x004E ; SPI1 Serial Transfer Complete
                                 .equ	TWI1addr	 = 0x0050 ; TWI Transfer Complete
                                 .equ	TIMER4_CAPTaddr	 = 0x0052 ; Timer/Counter4 Capture Event
                                 .equ	TIMER4_COMPAaddr	 = 0x0054 ; Timer/Counter4 Compare Match A
                                 .equ	TIMER4_COMPBaddr	 = 0x0056 ; Timer/Counter4 Compare Match B
                                 .equ	TIMER4_OVFaddr	 = 0x0058 ; Timer/Counter4 Overflow
                                 
                                 .equ	INT_VECTORS_SIZE	= 90 ; size in words
                                 
                                 #endif /* _M328PBDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 
                                 
                                 ; Universidad del Valle de Guatemala
                                 ; IE2023: ProgramaciÃ³n de Microcontroladores
                                 ; Proyecto No.1 - Reloj.asm 
                                 ; DescripciÃ³n: Reloj digital en formato 24 horas y fecha en formato (DD/MM) implementa un sistema 
                                 ;				de alarma audible. 
                                 ;***********************************************
                                 
                                 ; Incluye definiciones del microcontrolador ATmega328PB
                                 .include "m328pbdef.inc"    ; Incluye el archivo con las definiciones especÃ­ficas del ATmega328PB
                                 
                                 
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;*
                                 ;* Number            : AVR000
                                 ;* File Name         : m328PBdef.inc
                                 ;* Title             : Register/Bit Definitions for the ATmega328PB
                                 ;* Created           : 2021-07-13 10:39
                                 ;* Version           : 1.00
                                 ;* Support e-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328PB
                                 ;*
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal
                                 ;* SRAM is also defined
                                 ;*
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PBDEF_INC_
                                 #endif /* _M328PBDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 
                                 
                                 ;***********************************************
                                 ; CONSTANTES DEFINIDAS
                                 ;***********************************************
                                 .equ VALOR_COMPARACION = 60  ; Valor de comparaciÃ³n para el temporizador (60 para 1 minuto)
                                 .equ MIN_UNIT_DISP = 2       ; PC2: Pin para mostrar unidades de minutos en el display
                                 .equ MIN_DECS_DISP = 3       ; PC3: Pin para mostrar decenas de minutos en el display
                                 .equ HORA_UNIT_DISP = 4      ; PC4: Pin para mostrar unidades de horas en el display
                                 .equ HORA_DECS_DISP = 5      ; PC5: Pin para mostrar decenas de horas en el display
                                 .equ DIA_UNIT_DISP = 4       ; Reutiliza los mismos pines para mostrar la fecha (unidades del dÃ­a)
                                 .equ DIA_DECS_DISP = 5       ; Reutiliza los mismos pines para mostrar la fecha (decenas del dÃ­a)
                                 .equ MES_UNIT_DISP = 2       ; Pin para mostrar unidades del mes
                                 .equ MES_DECS_DISP = 3       ; Pin para mostrar decenas del mes
                                 .equ BOTON_FECHA = 3         ; Pin para el botÃ³n que cambia a modo de fecha
                                 .equ BOTON_MODO = 3          ; PB3: BotÃ³n para cambiar entre modos (hora/fecha/configuraciÃ³n)
                                 .equ BOTON_SELECCION = 2     ; PB2: BotÃ³n para seleccionar entre horas y minutos
                                 .equ BOTON_INCREMENTO = 0    ; PB0: BotÃ³n para incrementar el valor
                                 .equ BOTON_DECREMENTO = 1    ; PB1: BotÃ³n para decrementar el valor
                                 .equ LED_CONFIG_HORA = 4     ; PB4: LED indicador para modo de configuraciÃ³n de hora
                                 .equ LED_CONFIG_FECHA = 5    ; PB5: LED indicador para modo de configuraciÃ³n de fecha
                                 .equ LED_BIT = 7             ; PD7: Bit para controlar los LEDs
                                 .equ LED_CONFIG_ALARMA = 0   ; PC0: LED indicador para modo de configuraciÃ³n de alarma
                                 .equ BUZZER = 1              ; PC1: Pin para el buzzer que emite la alarma
                                 
                                 ;***********************************************
                                 ; DEFINICIÃN DE VARIABLES EN RAM
                                 ;***********************************************
                                 .dseg                       ; Segmento de datos (RAM)
                                 .org SRAM_START             ; Inicio de la RAM
                                 
000100                           timer_count:    .byte 1     ; Contador para el timer (cuenta hasta ~60 para formar 1 segundo)
000101                           segundos:       .byte 1     ; Contador de segundos (0-59)
000102                           min_unidades:   .byte 1     ; Unidades de minutos (0-9)
000103                           min_decenas:    .byte 1     ; Decenas de minutos (0-5)
000104                           hora_unidades:  .byte 1     ; Unidades de horas (0-9)
000105                           hora_decenas:   .byte 1     ; Decenas de horas (0-2)
000106                           dia_unidades:   .byte 1     ; Unidades del dÃ­a (0-9)
000107                           dia_decenas:    .byte 1     ; Decenas del dÃ­a (0-3)
000108                           mes_unidades:   .byte 1     ; Unidades del mes (0-9)
000109                           mes_decenas:    .byte 1     ; Decenas del mes (0-1)
00010a                           mostrar_fecha:  .byte 1     ; Flag para mostrar fecha (0 = hora, 1 = fecha)
00010b                           fecha_timer:    .byte 1     ; Contador para mostrar fecha temporalmente
00010c                           display_sel:    .byte 1     ; Selector de display (0-3) para la multiplexaciÃ³n
00010d                           led_counter:    .byte 1     ; Contador para parpadeo de LEDs (500ms)
00010e                           led_state:      .byte 1     ; Estado actual de los LEDs (0 = apagado, 1 = encendido)
00010f                           modo_reloj:     .byte 1     ; 0=hora, 1=fecha, 2=configuraciÃ³n
000110                           config_sel:     .byte 1     ; 0=horas, 1=minutos
000111                           alarma_hora_unidades: .byte 1  ; Unidades de hora para alarma (0-9)
000112                           alarma_hora_decenas:  .byte 1  ; Decenas de hora para alarma (0-2)
000113                           alarma_min_unidades:  .byte 1  ; Unidades de minutos para alarma (0-9)
000114                           alarma_min_decenas:   .byte 1  ; Decenas de minutos para alarma (0-5)
000115                           alarma_activa:        .byte 1  ; Estado de la alarma (0=inactiva, 1=activa)
000116                           alarma_sonando:       .byte 1  ; Indica si la alarma estÃ¡ sonando (0=no, 1=sÃ­)
000117                           portc_shadow: .byte 1         ; Sombra para PORTC (para control de displays)
000118                           buzzer_counter: .byte 1       ; Contador para el patrÃ³n de sonido del buzzer
                                 
                                 ;***********************************************
                                 ; SEGMENTO DE CÃDIGO
                                 ;***********************************************
                                 .cseg                       ; Segmento de cÃ³digo (Flash)
                                 
                                 ;***********************************************
                                 ; VECTORES DE INTERRUPCIÃN
                                 ;***********************************************
                                 .org 0x0000                 ; Vector de reset
000000 c025                          rjmp SETUP              ; Salta a la configuraciÃ³n inicial
                                 
                                 .org PCINT0addr             ; Vector de interrupciÃ³n para cambios en el pin
000006 c1a3                         rjmp PCINT0_ISR          ; Salta a la rutina de interrupciÃ³n del botÃ³n fecha
                                 
                                 .org TIMER0_OVFaddr         ; Vector de interrupciÃ³n Timer0
000020 c23a                          rjmp TMR0_ISR           ; Salta a la rutina del contador de tiempo
                                 
                                 ;***********************************************
                                 ; DEFINICIÃN DE REGISTROS
                                 ;***********************************************
                                 ; Registros principales
                                 .def temp = r16             ; Registro temporal para operaciones generales
                                 .def temp2 = r17            ; Segundo registro temporal
                                 .def digit = r18            ; Almacena el dÃ­gito actual a mostrar en el display
                                 .def mux_mask = r19         ; MÃ¡scara para el display activo en multiplexaciÃ³n
                                 .def display_pat = r20      ; PatrÃ³n para el display de 7 segmentos
                                 
                                 ;***********************************************
                                 ; TABLA DE VALORES PARA DISPLAY 7 SEGMENTOS
                                 ;***********************************************
                                 TABLA7SEG:                  ; Patrones para mostrar nÃºmeros 0-9 en display cÃ¡todo comÃºn
000021 063f
000022 4f5b
000023 6d66
000024 077d
000025 6f7f                          .db 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F
                                 
                                 ;***********************************************
                                 ; RUTINA DE CONFIGURACIÃN INICIAL
                                 ;***********************************************
                                 SETUP:
                                     ; ConfiguraciÃ³n del Stack Pointer
000026 e008                          ldi temp, high(RAMEND)  ; Carga la parte alta de la direcciÃ³n de fin de RAM
000027 bf0e                          out SPH, temp           ; Establece el puntero de pila alto
000028 ef0f                          ldi temp, low(RAMEND)   ; Carga la parte baja de la direcciÃ³n de fin de RAM
000029 bf0d                          out SPL, temp           ; Establece el puntero de pila bajo
                                 
                                     ; Deshabilita UART
00002a e000                          ldi temp, 0x00          ; Carga 0 en el registro temporal
00002b 9300 00c1                     sts UCSR0B, temp        ; Deshabilita la comunicaciÃ³n UART
                                 
                                     ; Configurar puertos B
00002d e300                      	ldi temp, (1<<LED_CONFIG_HORA)|(1<<LED_CONFIG_FECHA)  ; Configura PB4 y PB5 como salidas (LEDs)
00002e b904                      	out DDRB, temp           ; Establece la direcciÃ³n de datos para PORTB
00002f e00f                      	ldi temp, 0b00001111     ; Activa pull-ups en PB0-PB3 (botones)
000030 b905                      	out PORTB, temp          ; Establece el estado de PORTB
                                 
                                 	; Configurar interrupciones pin change para todos los botones
000031 e001                      	ldi temp, (1<<PCIE0)     ; Habilita interrupciones de cambio de pin para el grupo PORTB
000032 9300 0068                 	sts PCICR, temp          ; Establece el registro de control de interrupciones
000034 e00f                      	ldi temp, (1<<PCINT0)|(1<<PCINT1)|(1<<PCINT2)|(1<<PCINT3) ; Habilita interrupciones para botones
000035 9300 006b                 	sts PCMSK0, temp         ; Establece la mÃ¡scara de interrupciones para PORTB
                                 
                                     ; Configura PORTC para control de displays
000037 e30f                          ldi temp, 0x3F          ; Configura PC0-PC5 como salidas para el display
000038 b907                          out DDRC, temp          ; Establece la direcciÃ³n de datos para PORTC
000039 e000                          ldi temp, 0x00          ; Inicializa PORTC con todos los displays apagados
00003a b908                          out PORTC, temp         ; Establece el estado de PORTC
                                 
                                     ; Configura PORTD para segmentos del display y LEDs
00003b ef0f                          ldi temp, 0xFF          ; Configura todo PORTD como salidas (incluyendo PD7 para LEDs)
00003c b90a                          out DDRD, temp          ; Establece la direcciÃ³n de datos para PORTD
00003d e000                          ldi temp, 0x00          ; Inicializa PORTD con todos los segmentos y LEDs apagados
00003e b90b                          out PORTD, temp         ; Establece el estado de PORTD
                                 
                                     ; Configura Timer0
00003f e000                          ldi temp, 0x00          ; Configura Timer0 en modo normal
000040 bd04                          out TCCR0A, temp        ; Establece el registro de control del Timer0
000041 e005                          ldi temp, 0x05          ; Establece el prescaler a 1024
000042 bd05                          out TCCR0B, temp        ; Establece el registro de control del Timer0
000043 e001                          ldi temp, 0x01          ; Habilita la interrupciÃ³n por overflow del Timer0
000044 9300 006e                     sts TIMSK0, temp        ; Habilita interrupciÃ³n por overflow
                                 
                                   ; Inicializa variables en RAM
000046 e000                          ldi temp, 0                 ; Carga el valor 0 en el registro temporal 'temp'
000047 9300 0100                     sts timer_count, temp       ; Establece el contador del timer en 0
000049 9300 0101                     sts segundos, temp          ; Establece el contador de segundos en 0
00004b 9300 0102                     sts min_unidades, temp      ; Establece las unidades de minutos en 0
00004d 9300 0103                     sts min_decenas, temp       ; Establece las decenas de minutos en 0
00004f 9300 0104                     sts hora_unidades, temp     ; Establece las unidades de horas en 0
000051 9300 0105                     sts hora_decenas, temp      ; Establece las decenas de horas en 0
000053 9300 010f                     sts modo_reloj, temp        ; Establece el modo de reloj en 0 (hora)
000055 9300 0110                     sts config_sel, temp        ; Establece el selector de configuraciÃ³n en 0 (horas)
000057 9300 010c                     sts display_sel, temp       ; Establece el selector de display en 0
000059 9300 010d                     sts led_counter, temp       ; Establece el contador de LEDs en 0
00005b 9300 010e                     sts led_state, temp         ; Establece el estado de los LEDs en 0 (apagado)
00005d 9300 0111                     sts alarma_hora_unidades, temp  ; Establece las unidades de hora para la alarma en 0
00005f 9300 0112                     sts alarma_hora_decenas, temp     ; Establece las decenas de hora para la alarma en 0
000061 9300 0113                     sts alarma_min_unidades, temp      ; Establece las unidades de minutos para la alarma en 0
000063 9300 0114                     sts alarma_min_decenas, temp       ; Establece las decenas de minutos para la alarma en 0
000065 9300 0115                     sts alarma_activa, temp          ; Establece el estado de la alarma en 0 (inactiva)
000067 9300 0116                     sts alarma_sonando, temp         ; Establece el estado de la alarma sonando en 0 (no sonando)
000069 9300 0117                     sts portc_shadow, temp           ; Establece la sombra de PORTC en 0
00006b 9300 0118                     sts buzzer_counter, temp         ; Establece el contador del buzzer en 0
00006d 9300 0109                     sts mes_decenas, temp            ; Establece las decenas del mes en 0
00006f 9300 010a                     sts mostrar_fecha, temp          ; Establece el flag para mostrar fecha en 0 (hora)
000071 9300 010b                     sts fecha_timer, temp            ; Establece el contador de fecha en 0
000073 9300 0107                     sts dia_decenas, temp            ; Establece las decenas del dÃ­a en 0
                                 
                                     ; Inicializa variables de fecha (establecer la fecha inicial deseada)
000075 e001                          ldi temp, 1                     ; Carga el valor 1 en el registro temporal 'temp'
000076 9300 0106                     sts dia_unidades, temp          ; Establece las unidades del dÃ­a en 1 (primer dÃ­a del mes)
000078 9300 0108                     sts mes_unidades, temp          ; Establece las unidades del mes en 1 (enero)
                                 
00007a 9478                          sei                              ; Habilita interrupciones globales
                                 
                                 ;***********************************************
                                 ; LOOP PRINCIPAL
                                 ;***********************************************
                                 MAIN:
00007b d004                          rcall APAGAR_DISPLAYS           ; Llama a la subrutina para apagar todos los displays
00007c d007                          rcall SELECCIONAR_DISPLAY       ; Llama a la subrutina para seleccionar quÃ© display mostrar
00007d d10b                          rcall MOSTRAR_DIGITO            ; Llama a la subrutina para mostrar el dÃ­gito correspondiente
00007e d127                          rcall DELAY_MUX                 ; Llama a la subrutina para un pequeÃ±o delay en la multiplexaciÃ³n
00007f cffb                          rjmp MAIN                       ; Repite indefinidamente el loop principal
                                 
                                 ;***********************************************
                                 ; SUBRUTINAS DEL PROGRAMA PRINCIPAL
                                 ;***********************************************
                                 ;----------------------------------------------
                                 ; APAGAR_DISPLAYS: Apaga los displays sin afectar el buzzer y LED
                                 ;-----------------------------------------
                                 APAGAR_DISPLAYS:
000080 b108                          in temp, PORTC                 ; Lee el estado actual de PORTC y lo almacena en 'temp'
000081 7003                          andi temp, 0b00000011          ; Mantiene los bits 0-1 (buzzer y LED), apaga displays (PC2-PC5)
000082 b908                          out PORTC, temp                ; Escribe el estado modificado de PORTC (apaga displays)
000083 9508                          ret                             ; Retorna de la subrutina
                                 
                                 
                                 ;----------------------------------------------
                                 ; SELECCIONAR_DISPLAY: Determina quÃ© display mostrar
                                 ;----------------------------------------------
                                 SELECCIONAR_DISPLAY:
                                     ; Verifica el modo actual del reloj
000084 9100 010f                     lds temp, modo_reloj							; Carga el valor del modo actual en 'temp'
000086 3001                          cpi temp, 1										; Compara 'temp' con 1 (modo de fecha)
000087 f039                          breq SELECCIONAR_DISPLAY_FECHA_LOCAL			; Si es igual, salta a la selecciÃ³n de fecha
000088 3002                          cpi temp, 2										; Compara 'temp' con 2 (modo de configuraciÃ³n de hora)
000089 f031                          breq SELECCIONAR_DISPLAY_CONFIG_HORA_LOCAL		; Si es igual, salta a la selecciÃ³n de configuraciÃ³n de hora
00008a 3003                          cpi temp, 3										; Compara 'temp' con 3 (modo de configuraciÃ³n de fecha)
00008b f029                          breq SELECCIONAR_DISPLAY_CONFIG_FECH_LOCAL		; Si es igual, salta a la selecciÃ³n de configuraciÃ³n de fecha
00008c 3004                          cpi temp, 4										; Compara 'temp' con 4 (modo de configuraciÃ³n de alarma)
00008d f021                          breq SELECCIONAR_DISPLAY_CONFIG_ALARMA_LOCAL    ; Si es igual, salta a la selecciÃ³n de configuraciÃ³n de alarma
00008e c004                          rjmp FIN_SELECCION								; Si no coincide con ninguno, salta a la finalizaciÃ³n de selecciÃ³n
                                 	 
                                 SELECCIONAR_DISPLAY_FECHA_LOCAL:
00008f c01e                          rjmp SELECCIONAR_DISPLAY_FECHA ; Salta a la subrutina para seleccionar el display de fecha
                                     
                                 SELECCIONAR_DISPLAY_CONFIG_HORA_LOCAL:
000090 c038                          rjmp SELECCIONAR_DISPLAY_CONFIG_HORA ; Salta a la subrutina para seleccionar el display de configuraciÃ³n de hora
                                     
                                 SELECCIONAR_DISPLAY_CONFIG_FECH_LOCAL:
000091 c077                          rjmp SELECCIONAR_DISPLAY_CONFIG_FECHA ; Salta a la subrutina para seleccionar el display de configuraciÃ³n de fecha
                                     
                                 SELECCIONAR_DISPLAY_CONFIG_ALARMA_LOCAL:
000092 c0b6                          rjmp SELECCIONAR_DISPLAY_ALARMA ; Salta a la subrutina para seleccionar el display de configuraciÃ³n de alarma
                                     
                                 FIN_SELECCION:
                                     ; Modo 0: Mostrar hora 
000093 9100 010c                     lds temp, display_sel          ; Carga el valor del selector de display en 'temp'
000095 3000                          cpi temp, 0                    ; Compara 'temp' con 0 (unidades de minutos)
000096 f039                          breq SELECT_MIN_UNIDADES       ; Si es igual, salta a la selecciÃ³n de unidades de minutos
000097 3001                          cpi temp, 1                    ; Compara 'temp' con 1 (decenas de minutos)
000098 f049                          breq SELECT_MIN_DECENAS		   ; Si es igual, salta a la selecciÃ³n de decenas de minutos
000099 3002                          cpi temp, 2                    ; Compara 'temp' con 2 (unidades de horas)
00009a f059                          breq SELECT_HORA_UNIDADES      ; Si es igual, salta a la selecciÃ³n de unidades de horas
00009b 3003                          cpi temp, 3                    ; Compara 'temp' con 3 (decenas de horas)
00009c f069                          breq SELECT_HORA_DECENAS       ; Si es igual, salta a la selecciÃ³n de decenas de horas
00009d c000                          rjmp SELECT_MIN_UNIDADES       ; Por seguridad, vuelve a unidades de minutos si no coincide
                                 
                                 SELECT_MIN_UNIDADES:
00009e 9120 0102                     lds digit, min_unidades          ; Carga el valor de las unidades de minutos en 'digit'
0000a0 e034                          ldi mux_mask, (1<<MIN_UNIT_DISP) ; Establece la mÃ¡scara para el display de unidades de minutos
0000a1 9508                          ret                              ; Retorna de la subrutina
                                 
                                 SELECT_MIN_DECENAS:
0000a2 9120 0103                     lds digit, min_decenas           ; Carga el valor de las decenas de minutos en 'digit'
0000a4 e038                          ldi mux_mask, (1<<MIN_DECS_DISP) ; Establece la mÃ¡scara para el display de decenas de minutos
0000a5 9508                          ret                              ; Retorna de la subrutina
                                     
                                 SELECT_HORA_UNIDADES:
0000a6 9120 0104                     lds digit, hora_unidades          ; Carga el valor de las unidades de horas en 'digit'
0000a8 e130                          ldi mux_mask, (1<<HORA_UNIT_DISP) ; Establece la mÃ¡scara para el display de unidades de horas
0000a9 9508                          ret                               ; Retorna de la subrutina
                                     
                                 SELECT_HORA_DECENAS:
0000aa 9120 0105                     lds digit, hora_decenas           ; Carga el valor de las decenas de horas en 'digit'
0000ac e230                          ldi mux_mask, (1<<HORA_DECS_DISP) ; Establece la mÃ¡scara para el display de decenas de horas
0000ad 9508                          ret                               ; Retorna de la subrutina
                                 
                                 SELECCIONAR_DISPLAY_FECHA:
                                     ; Mostrar fecha
0000ae 9100 010c                     lds temp, display_sel          ; Carga el valor del selector de display en 'temp'
0000b0 3000                          cpi temp, 0                    ; Compara 'temp' con 0 (unidades del dÃ­a)
0000b1 f039                          breq SELECT_DIA_UNIDADES       ; Si es igual, salta a la selecciÃ³n de unidades del dÃ­a
0000b2 3001                          cpi temp, 1                    ; Compara 'temp' con 1 (decenas del dÃ­a)
0000b3 f049                          breq SELECT_DIA_DECENAS        ; Si es igual, salta a la selecciÃ³n de decenas del dÃ­a
0000b4 3002                          cpi temp, 2                    ; Compara 'temp' con 2 (unidades del mes)
0000b5 f059                          breq SELECT_MES_UNIDADES       ; Si es igual, salta a la selecciÃ³n de unidades del mes
0000b6 3003                          cpi temp, 3                    ; Compara 'temp' con 3 (decenas del mes)
0000b7 f069                          breq SELECT_MES_DECENAS        ; Si es igual, salta a la selecciÃ³n de decenas del mes
0000b8 c000                          rjmp SELECT_DIA_UNIDADES       ; Por seguridad, vuelve a unidades de dÃ­as si no coincide
                                 
                                 SELECT_DIA_UNIDADES:
0000b9 9120 0106                     lds digit, dia_unidades        ; Carga el valor de las unidades del dÃ­a en 'digit'
0000bb e130                          ldi mux_mask, (1<<DIA_UNIT_DISP) ; Establece la mÃ¡scara para el display de unidades del dÃ­a
0000bc 9508                          ret                             ; Retorna de la subrutina
                                 
                                 SELECT_DIA_DECENAS:
0000bd 9120 0107                     lds digit, dia_decenas         ; Carga el valor de las decenas del dÃ­a en 'digit'
0000bf e230                          ldi mux_mask, (1<<DIA_DECS_DISP) ; Establece la mÃ¡scara para el display de decenas del dÃ­a
0000c0 9508                          ret                             ; Retorna de la subrutina
                                 
                                 SELECT_MES_UNIDADES:
0000c1 9120 0108                     lds digit, mes_unidades        ; Carga el valor de las unidades del mes en 'digit'
0000c3 e034                          ldi mux_mask, (1<<MES_UNIT_DISP) ; Establece la mÃ¡scara para el display de unidades del mes
0000c4 9508                          ret                             ; Retorna de la subrutina
                                 
                                 SELECT_MES_DECENAS:
0000c5 9120 0109                     lds digit, mes_decenas         ; Carga el valor de las decenas del mes en 'digit'
0000c7 e038                          ldi mux_mask, (1<<MES_DECS_DISP) ; Establece la mÃ¡scara para el display de decenas del mes
0000c8 9508                          ret                             ; Retorna de la subrutina
                                 
                                 
                                 SELECCIONAR_DISPLAY_CONFIG_HORA:
                                     ; Modo 2: Mostrar hora con parpadeo en el valor que se estÃ¡ configurando
0000c9 9100 010c                     lds temp, display_sel          ; Carga el valor del selector de display en 'temp'
0000cb 3000                          cpi temp, 0                    ; Compara 'temp' con 0 (unidades de minutos)
0000cc f039                          breq SELECT_CONFIG_MIN_UNIDADES ; Si es igual, salta a la selecciÃ³n de unidades de minutos
0000cd 3001                          cpi temp, 1                    ; Compara 'temp' con 1 (decenas de minutos)
0000ce f091                          breq SELECT_CONFIG_MIN_DECENAS  ; Si es igual, salta a la selecciÃ³n de decenas de minutos
0000cf 3002                          cpi temp, 2                    ; Compara 'temp' con 2 (unidades de horas)
0000d0 f0e9                          breq SELECT_CONFIG_HORA_UNIDADES ; Si es igual, salta a la selecciÃ³n de unidades de horas
0000d1 3003                          cpi temp, 3                    ; Compara 'temp' con 3 (decenas de horas)
0000d2 f141                          breq SELECT_CONFIG_HORA_DECENAS  ; Si es igual, salta a la selecciÃ³n de decenas de horas
0000d3 c000                          rjmp SELECT_CONFIG_MIN_UNIDADES ; Por seguridad, vuelve a unidades de minutos
                                 
                                 SELECT_CONFIG_MIN_UNIDADES:
0000d4 9120 0102                     lds digit, min_unidades        ; Carga el valor de las unidades de minutos en 'digit'
0000d6 e034                          ldi mux_mask, (1<<MIN_UNIT_DISP) ; Establece la mÃ¡scara para el display de unidades de minutos
                                     
                                     ; Si estamos configurando minutos, parpadear unidades
0000d7 9100 0110                     lds temp, config_sel           ; Carga el valor del selector de configuraciÃ³n en 'temp'
0000d9 3001                          cpi temp, 1                    ; Compara 'temp' con 1 (modo de configuraciÃ³n de minutos)
0000da f569                          brne DISPLAY_CONFIG_DIGIT      ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
0000db 9100 010e                     lds temp, led_state            ; Carga el estado de los LEDs en 'temp'
0000dd 3000                          cpi temp, 0                    ; Compara 'temp' con 0 (LED apagado)
0000de f549                          brne DISPLAY_CONFIG_DIGIT      ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
0000df e030                          ldi mux_mask, 0                ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
0000e0 9508                          ret                             ; Retorna de la subrutina
                                     
                                 SELECT_CONFIG_MIN_DECENAS:
0000e1 9120 0103                     lds digit, min_decenas         ; Carga el valor de las decenas de minutos en 'digit'
0000e3 e038                          ldi mux_mask, (1<<MIN_DECS_DISP) ; Establece la mÃ¡scara para el display de decenas de minutos
                                     
                                     ; Si estamos configurando minutos, parpadear decenas
0000e4 9100 0110                     lds temp, config_sel           ; Carga el valor del selector de configuraciÃ³n en 'temp'
0000e6 3001                          cpi temp, 1                    ; Compara 'temp' con 1 (modo de configuraciÃ³n de minutos)
0000e7 f501                          brne DISPLAY_CONFIG_DIGIT      ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
0000e8 9100 010e                     lds temp, led_state            ; Carga el estado de los LEDs en 'temp'
0000ea 3000                          cpi temp, 0                    ; Compara 'temp' con 0 (LED apagado)
0000eb f4e1                          brne DISPLAY_CONFIG_DIGIT      ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
0000ec e030                          ldi mux_mask, 0                ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
0000ed 9508                          ret                             ; Retorna de la subrutina
                                     
                                 SELECT_CONFIG_HORA_UNIDADES:
0000ee 9120 0104                     lds digit, hora_unidades       ; Carga el valor de las unidades de horas en 'digit'
0000f0 e130                          ldi mux_mask, (1<<HORA_UNIT_DISP) ; Establece la mÃ¡scara para el display de unidades de horas
                                     
                                     ; Si estamos configurando horas, parpadear unidades
0000f1 9100 0110                     lds temp, config_sel           ; Carga el valor del selector de configuraciÃ³n en 'temp'
0000f3 3000                          cpi temp, 0                    ; Compara 'temp' con 0 (modo de configuraciÃ³n de horas)
0000f4 f499                          brne DISPLAY_CONFIG_DIGIT      ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
0000f5 9100 010e                     lds temp, led_state            ; Carga el estado de los LEDs en 'temp'
0000f7 3000                          cpi temp, 0                    ; Compara 'temp' con 0 (LED apagado)
0000f8 f479                          brne DISPLAY_CONFIG_DIGIT      ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
0000f9 e030                          ldi mux_mask, 0                ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
0000fa 9508                          ret                            ; Retorna de la subrutina
                                     
                                 SELECT_CONFIG_HORA_DECENAS:
0000fb 9120 0105                     lds digit, hora_decenas        ; Carga el valor de las decenas de horas en 'digit'
0000fd e230                          ldi mux_mask, (1<<HORA_DECS_DISP) ; Establece la mÃ¡scara para el display de decenas de horas
                                     
                                     ; Si estamos configurando horas, parpadear decenas
0000fe 9100 0110                     lds temp, config_sel           ; Carga el valor del selector de configuraciÃ³n en 'temp'
000100 3000                          cpi temp, 0                    ; Compara 'temp' con 0 (modo de configuraciÃ³n de horas)
000101 f431                          brne DISPLAY_CONFIG_DIGIT      ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
000102 9100 010e                     lds temp, led_state            ; Carga el estado de los LEDs en 'temp'
000104 3000                          cpi temp, 0                    ; Compara 'temp' con 0 (LED apagado)
000105 f411                          brne DISPLAY_CONFIG_DIGIT      ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
000106 e030                          ldi mux_mask, 0                 ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
000107 9508                          ret                             ; Retorna de la subrutina
                                     
                                 DISPLAY_CONFIG_DIGIT:
000108 9508                          ret                             ; Retorna de la subrutina
                                 
                                 SELECCIONAR_DISPLAY_CONFIG_FECHA:
                                     ; Modo 3: Mostrar fecha con parpadeo en el valor que se estÃ¡ configurando
000109 9100 010c                     lds temp, display_sel				; Carga el valor del selector de display en 'temp'
00010b 3000                          cpi temp, 0							; Compara 'temp' con 0 (unidades del dÃ­a)
00010c f039                          breq SELECT_CONFIG_DIA_UNIDADES		; Si es igual, salta a la selecciÃ³n de unidades del dÃ­a
00010d 3001                          cpi temp, 1							; Compara 'temp' con 1 (decenas del dÃ­a)
00010e f091                          breq SELECT_CONFIG_DIA_DECENAS		; Si es igual, salta a la selecciÃ³n de decenas del dÃ­a
00010f 3002                          cpi temp, 2							; Compara 'temp' con 2 (unidades del mes)
000110 f0e9                          breq SELECT_CONFIG_MES_UNIDADES		; Si es igual, salta a la selecciÃ³n de unidades del mes
000111 3003                          cpi temp, 3							; Compara 'temp' con 3 (decenas del mes)
000112 f141                          breq SELECT_CONFIG_MES_DECENAS		; Si es igual, salta a la selecciÃ³n de decenas del mes
000113 c000                          rjmp SELECT_CONFIG_DIA_UNIDADES		; Por seguridad, vuelve a unidades de dÃ­as si no coincide
                                 
                                 SELECT_CONFIG_DIA_UNIDADES:
000114 9120 0106                     lds digit, dia_unidades				; Carga el valor de las unidades del dÃ­a en 'digit'
000116 e130                          ldi mux_mask, (1<<DIA_UNIT_DISP)	; Establece la mÃ¡scara para el display de unidades del dÃ­a
                                     
                                     ; Si estamos configurando dÃ­as, parpadear unidades
000117 9100 0110                     lds temp, config_sel				; Carga el valor del selector de configuraciÃ³n en 'temp'
000119 3000                          cpi temp, 0							; Compara 'temp' con 0 (modo de configuraciÃ³n de dÃ­as)
00011a f569                          brne DISPLAY_CONFIG_FECHA_DIGIT		; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
00011b 9100 010e                     lds temp, led_state					; Carga el estado de los LEDs en 'temp'
00011d 3000                          cpi temp, 0							; Compara 'temp' con 0 (LED apagado)
00011e f549                          brne DISPLAY_CONFIG_FECHA_DIGIT		; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
00011f e030                          ldi mux_mask, 0                ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
000120 9508                          ret                             ; Retorna de la subrutina
                                     
                                 SELECT_CONFIG_DIA_DECENAS:
000121 9120 0107                     lds digit, dia_decenas				; Carga el valor de las decenas del dÃ­a en 'digit'
000123 e230                          ldi mux_mask, (1<<DIA_DECS_DISP)	; Establece la mÃ¡scara para el display de decenas del dÃ­a
                                     
                                     ; Si estamos configurando dÃ­as, parpadear decenas
000124 9100 0110                     lds temp, config_sel				; Carga el valor del selector de configuraciÃ³n en 'temp'
000126 3000                          cpi temp, 0							; Compara 'temp' con 0 (modo de configuraciÃ³n de dÃ­as)
000127 f501                          brne DISPLAY_CONFIG_FECHA_DIGIT		; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
000128 9100 010e                     lds temp, led_state					; Carga el estado de los LEDs en 'temp'
00012a 3000                          cpi temp, 0							; Compara 'temp' con 0 (LED apagado)
00012b f4e1                          brne DISPLAY_CONFIG_FECHA_DIGIT		; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
00012c e030                          ldi mux_mask, 0                 ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
00012d 9508                          ret                             ; Retorna de la subrutina
                                     
                                 SELECT_CONFIG_MES_UNIDADES:
00012e 9120 0108                     lds digit, mes_unidades			 ; Carga el valor de las unidades del mes en 'digit'
000130 e034                          ldi mux_mask, (1<<MES_UNIT_DISP) ; Establece la mÃ¡scara para el display de unidades del mes
                                     
                                     ; Si estamos configurando meses, parpadear unidades
000131 9100 0110                     lds temp, config_sel			; Carga el valor del selector de configuraciÃ³n en 'temp'
000133 3001                          cpi temp, 1						; Compara 'temp' con 1 (modo de configuraciÃ³n de meses)
000134 f499                          brne DISPLAY_CONFIG_FECHA_DIGIT ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
000135 9100 010e                     lds temp, led_state				; Carga el estado de los LEDs en 'temp'
000137 3000                          cpi temp, 0						; Compara 'temp' con 0 (LED apagado)
000138 f479                          brne DISPLAY_CONFIG_FECHA_DIGIT ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
000139 e030                          ldi mux_mask, 0					; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
00013a 9508                          ret                             ; Retorna de la subrutina
                                     
                                 SELECT_CONFIG_MES_DECENAS:
00013b 9120 0109                     lds digit, mes_decenas			 ; Carga el valor de las decenas del mes en 'digit'
00013d e038                          ldi mux_mask, (1<<MES_DECS_DISP) ; Establece la mÃ¡scara para el display de decenas del mes
                                     
                                     ; Si estamos configurando meses, parpadear decenas
00013e 9100 0110                     lds temp, config_sel			; Carga el valor del selector de configuraciÃ³n en 'temp'
000140 3001                          cpi temp, 1						; Compara 'temp' con 1 (modo de configuraciÃ³n de meses)
000141 f431                          brne DISPLAY_CONFIG_FECHA_DIGIT ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
000142 9100 010e                     lds temp, led_state				; Carga el estado de los LEDs en 'temp'
000144 3000                          cpi temp, 0						; Compara 'temp' con 0 (LED apagado)
000145 f411                          brne DISPLAY_CONFIG_FECHA_DIGIT ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
000146 e030                          ldi mux_mask, 0                 ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
000147 9508                          ret                             ; Retorna de la subrutina
                                     
                                 DISPLAY_CONFIG_FECHA_DIGIT:
000148 9508                          ret                             ; Retorna de la subrutina
                                 
                                 SELECCIONAR_DISPLAY_ALARMA:
                                     ; Modo 4: Mostrar alarma con parpadeo en el valor que se estÃ¡ configurando
000149 9100 010c                     lds temp, display_sel          ; Carga el valor del selector de display en 'temp'
00014b 3000                          cpi temp, 0                    ; Compara 'temp' con 0 (unidades de minutos de la alarma)
00014c f039                          breq SELECT_ALARMA_MIN_UNIDADES ; Si es igual, salta a la selecciÃ³n de unidades de minutos
00014d 3001                          cpi temp, 1                    ; Compara 'temp' con 1 (decenas de minutos de la alarma)
00014e f091                          breq SELECT_ALARMA_MIN_DECENAS  ; Si es igual, salta a la selecciÃ³n de decenas de minutos
00014f 3002                          cpi temp, 2                    ; Compara 'temp' con 2 (unidades de horas de la alarma)
000150 f0e9                          breq SELECT_ALARMA_HORA_UNIDADES ; Si es igual, salta a la selecciÃ³n de unidades de horas
000151 3003                          cpi temp, 3                    ; Compara 'temp' con 3 (decenas de horas de la alarma)
000152 f141                          breq SELECT_ALARMA_HORA_DECENAS  ; Si es igual, salta a la selecciÃ³n de decenas de horas
000153 c000                          rjmp SELECT_ALARMA_MIN_UNIDADES ; Por seguridad, vuelve a unidades de minutos si no coincide
                                 
                                 SELECT_ALARMA_MIN_UNIDADES:
000154 9120 0113                     lds digit, alarma_min_unidades   ; Carga el valor de las unidades de minutos de la alarma en 'digit'
000156 e034                          ldi mux_mask, (1<<MIN_UNIT_DISP) ; Establece la mÃ¡scara para el display de unidades de minutos
                                     
                                     ; Si estamos configurando minutos, parpadeo en unidades
000157 9100 0110                     lds temp, config_sel            ; Carga el valor del selector de configuraciÃ³n en 'temp'
000159 3001                          cpi temp, 1                     ; Compara 'temp' con 1 (modo de configuraciÃ³n de minutos)
00015a f569                          brne DISPLAY_ALARMA_DIGIT       ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
00015b 9100 010e                     lds temp, led_state             ; Carga el estado de los LEDs en 'temp'
00015d 3000                          cpi temp, 0                     ; Compara 'temp' con 0 (LED apagado)
00015e f549                          brne DISPLAY_ALARMA_DIGIT       ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
00015f e030                          ldi mux_mask, 0                  ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
000160 9508                          ret                              ; Retorna de la subrutina
                                     
                                 SELECT_ALARMA_MIN_DECENAS:
000161 9120 0114                     lds digit, alarma_min_decenas     ; Carga el valor de las decenas de minutos de la alarma en 'digit'
000163 e038                          ldi mux_mask, (1<<MIN_DECS_DISP)  ; Establece la mÃ¡scara para el display de decenas de minutos
                                     
                                     ; Si estamos configurando minutos, parpadeo en decenas
000164 9100 0110                     lds temp, config_sel             ; Carga el valor del selector de configuraciÃ³n en 'temp'
000166 3001                          cpi temp, 1                      ; Compara 'temp' con 1 (modo de configuraciÃ³n de minutos)
000167 f501                          brne DISPLAY_ALARMA_DIGIT        ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
000168 9100 010e                     lds temp, led_state              ; Carga el estado de los LEDs en 'temp'
00016a 3000                          cpi temp, 0                      ; Compara 'temp' con 0 (LED apagado)
00016b f4e1                          brne DISPLAY_ALARMA_DIGIT        ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
00016c e030                          ldi mux_mask, 0                   ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
00016d 9508                          ret                               ; Retorna de la subrutina
                                     
                                 SELECT_ALARMA_HORA_UNIDADES:
00016e 9120 0111                     lds digit, alarma_hora_unidades		; Carga el valor de las unidades de horas de la alarma en 'digit'
000170 e130                          ldi mux_mask, (1<<HORA_UNIT_DISP)	; Establece la mÃ¡scara para el display de unidades de horas
                                     
                                     ; Si estamos configurando horas, parpadeo en unidades
000171 9100 0110                     lds temp, config_sel             ; Carga el valor del selector de configuraciÃ³n en 'temp'
000173 3000                          cpi temp, 0                      ; Compara 'temp' con 0 (modo de configuraciÃ³n de horas)
000174 f499                          brne DISPLAY_ALARMA_DIGIT        ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
000175 9100 010e                     lds temp, led_state              ; Carga el estado de los LEDs en 'temp'
000177 3000                          cpi temp, 0                      ; Compara 'temp' con 0 (LED apagado)
000178 f479                          brne DISPLAY_ALARMA_DIGIT        ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
000179 e030                          ldi mux_mask, 0					  ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
00017a 9508                          ret                               ; Retorna de la subrutina
                                     
                                 SELECT_ALARMA_HORA_DECENAS:
00017b 9120 0112                     lds digit, alarma_hora_decenas		; Carga el valor de las decenas de horas de la alarma en 'digit'
00017d e230                          ldi mux_mask, (1<<HORA_DECS_DISP)   ; Establece la mÃ¡scara para el display de decenas de horas
                                     
                                     ; Si estamos configurando horas, parpadeo en decenas
00017e 9100 0110                     lds temp, config_sel             ; Carga el valor del selector de configuraciÃ³n en 'temp'
000180 3000                          cpi temp, 0                      ; Compara 'temp' con 0 (modo de configuraciÃ³n de horas)
000181 f431                          brne DISPLAY_ALARMA_DIGIT        ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Parpadeo usando el contador de LEDs
000182 9100 010e                     lds temp, led_state              ; Carga el estado de los LEDs en 'temp'
000184 3000                          cpi temp, 0                      ; Compara 'temp' con 0 (LED apagado)
000185 f411                          brne DISPLAY_ALARMA_DIGIT        ; Si no es igual, salta a la rutina de configuraciÃ³n de dÃ­gitos
                                     
                                     ; Durante parpadeo, apagar dÃ­gito
000186 e030                          ldi mux_mask, 0					  ; Establece la mÃ¡scara a 0 para apagar el dÃ­gito
000187 9508                          ret                               ; Retorna de la subrutina
                                     
                                 DISPLAY_ALARMA_DIGIT:
000188 9508                          ret                               ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; MOSTRAR_DIGITO: Muestra el dÃ­gito en el display seleccionado
                                 ;----------------------------------------------
                                 MOSTRAR_DIGITO:
                                     ; Obtener patrÃ³n para el dÃ­gito actual
000189 e0f0                          ldi ZH, high(TABLA7SEG*2)      ; Carga la parte alta de la direcciÃ³n de la tabla de patrones
00018a e4e2                          ldi ZL, low(TABLA7SEG*2)       ; Carga la parte baja de la direcciÃ³n de la tabla de patrones
                                     
                                     ; Verificar que el dÃ­gito estÃ© en rango (0-9)
00018b 2f02                          mov temp, digit                 ; Mueve el dÃ­gito actual a 'temp'
00018c 300a                          cpi temp, 10                    ; Compara 'temp' con 10
00018d f010                          brlo VALID_DIGIT                ; Si estÃ¡ en rango, salta a VALID_DIGIT
00018e e000                          ldi temp, 0                     ; Si no estÃ¡ en rango, establece 'temp' a 0
00018f 2f20                          mov digit, temp                 ; Actualiza 'digit' a 0
                                     
                                 VALID_DIGIT:
000190 0fe2                          add ZL, digit                   ; Suma el dÃ­gito al puntero de la tabla
000191 f408                          brcc NO_CARRY_PATTERN           ; Si no hay acarreo, salta a NO_CARRY_PATTERN
000192 95f3                          inc ZH                          ; Incrementa la parte alta si hay acarreo
                                 
                                 NO_CARRY_PATTERN:
000193 9144                          lpm display_pat, Z              ; Lee el patrÃ³n del dÃ­gito de la tabla
                                     
                                     ; Mantiene el estado de los LEDs en PD7 al actualizar el display
000194 b10b                          in temp, PORTD                  ; Lee el estado actual de PORTD
000195 7800                          andi temp, (1<<LED_BIT)         ; Mantiene solo el bit LED_BIT
000196 2b40                          or display_pat, temp            ; Combina el patrÃ³n del display con el estado de los LEDs
                                     
                                     ; Aplica el patrÃ³n al display
000197 b94b                          out PORTD, display_pat          ; EnvÃ­a el patrÃ³n al puerto D
                                     
                                     ; Activa el display correspondiente
000198 9100 0117                     lds temp, portc_shadow          ; Carga el estado actual guardado de PORTC
00019a 7003                          andi temp, 0b00000011           ; Mantiene solo los bits 0-1 (buzzer y LED)
00019b 2b03                          or temp, mux_mask               ; AÃ±ade la mÃ¡scara de multiplexiÃ³n
00019c b908                          out PORTC, temp                 ; Actualiza el puerto C
                                 	
                                     ; Incrementa selector para el siguiente ciclo
00019d 9100 010c                     lds temp, display_sel           ; Carga el selector de display
00019f 9503                          inc temp                        ; Incrementa el selector
0001a0 3004                          cpi temp, 4                     ; Compara con 4
0001a1 f409                          brne SAVE_DISPLAY_SEL           ; Si no es igual, salta a SAVE_DISPLAY_SEL
0001a2 e000                          ldi temp, 0                     ; Reinicia a 0 cuando llega a 4
                                     
                                 SAVE_DISPLAY_SEL:
0001a3 9300 010c                     sts display_sel, temp           ; Guarda el nuevo valor del selector
0001a5 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; DELAY_MUX: PequeÃ±o delay para multiplexaciÃ³n
                                 ;----------------------------------------------
                                 DELAY_MUX:
0001a6 e302                          ldi temp, 50                  ; Carga el valor 50 en el registro 'temp' para contar el delay
                                 DELAY_LOOP:
0001a7 950a                          dec temp                      ; Decrementa el valor de 'temp' en 1
0001a8 f7f1                          brne DELAY_LOOP               ; Si 'temp' no es cero, salta de nuevo a DELAY_LOOP
0001a9 9508                          ret                           ; Retorna de la subrutina una vez que el delay ha terminado
                                 
                                 ;***********************************************
                                 ; RUTINA DE INTERRUPCIÃN PARA BOTONES
                                 ;***********************************************
                                 PCINT0_ISR:
                                     ; Guarda contexto
0001aa 930f                          push temp                   ; Guarda el registro 'temp' en la pila
0001ab b70f                          in temp, SREG               ; Lee el registro de estado (SREG) y lo guarda en 'temp'
0001ac 930f                          push temp                   ; Guarda el registro de estado en la pila
0001ad 931f                          push temp2                  ; Guarda el registro 'temp2' en la pila para preservar su valor
                                     
                                     ; Verificar si la alarma estÃ¡ sonando
0001ae 9100 0116                     lds temp, alarma_sonando    ; Carga el estado de la alarma en 'temp'
0001b0 3000                          cpi temp, 0                  ; Compara 'temp' con 0 (alarma no sonando)
0001b1 f081                          breq CONTINUE_PCINT0        ; Si la alarma no estÃ¡ sonando, salta a CONTINUE_PCINT0
                                     
                                     ; La alarma estÃ¡ sonando, verificar si algÃºn botÃ³n fue presionado
0001b2 b103                          in temp, PINB               ; Lee el estado de los botones en PORTB
0001b3 700f                          andi temp, 0x0F             ; Verifica solo los botones PB0-PB3
0001b4 300f                          cpi temp, 0x0F              ; Compara con 0x0F (ningÃºn botÃ³n presionado)
0001b5 f061                          breq CONTINUE_PCINT0        ; Si no se presionÃ³ ningÃºn botÃ³n, salta a CONTINUE_PCINT0
                                     
                                     ; AlgÃºn botÃ³n fue presionado, apagar la alarma
0001b6 e000                          ldi temp, 0                  ; Carga 0 en 'temp' para apagar la alarma
0001b7 9300 0116                     sts alarma_sonando, temp     ; Establece el estado de la alarma como no sonando
                                     
                                     ; IMPORTANTE: TambiÃ©n desactivar la alarma para que no se vuelva a activar automÃ¡ticamente
0001b9 9300 0115                     sts alarma_activa, temp      ; Establece el estado de la alarma como inactiva
                                     
                                     ; Usar registro sombra para apagar el buzzer
0001bb 9100 0117                     lds temp, portc_shadow       ; Carga el estado actual guardado de PORTC
0001bd 7f0d                          andi temp, ~(1<<1)           ; Apaga el buzzer en PORTC1 (bit 1)
0001be 9300 0117                     sts portc_shadow, temp       ; Actualiza el registro sombra
0001c0 b908                          out PORTC, temp              ; Actualiza el puerto fÃ­sico para apagar el buzzer
                                     
0001c1 c094                          rjmp PCINT0_EXIT             ; Salta a la salida de la rutina de interrupciÃ³n
                                 
                                 CONTINUE_PCINT0:
                                     ; Leer estado actual de PINB - Los botones estÃ¡n con pull-up (0 = presionado)
0001c2 b103                          in temp, PINB                ; Lee el estado de los botones en PORTB
                                     
                                     ; BotÃ³n MODO (PB3) - Verifica si estÃ¡ presionado (bit = 0)
0001c3 fd03                          sbrc temp, BOTON_MODO        ; Salta si el bit correspondiente a BOTON_MODO estÃ¡ limpio (no presionado)
0001c4 c028                          rjmp CHECK_BOTONES_CONFIG    ; Si no estÃ¡ presionado, verifica otros botones
                                     
                                     ; El botÃ³n modo estÃ¡ presionado - cambiar modo
0001c5 9100 010f                     lds temp, modo_reloj         ; Carga el modo actual en 'temp'
0001c7 9503                          inc temp                     ; Incrementa el modo
0001c8 3005                          cpi temp, 5                  ; Compara 'temp' con 5 (mÃ¡ximo modo)
0001c9 f409                          brne SAVE_MODO               ; Si no ha llegado a 5, guarda el nuevo modo
0001ca e000                          ldi temp, 0                  ; Si llegÃ³ a 5, reinicia el modo a 0          ; SÃ­, volver a modo 0
                                     
                                 SAVE_MODO:
0001cb 9300 010f                     sts modo_reloj, temp              ; Guarda el nuevo modo en la variable 'modo_reloj'
                                     
                                     ; Apagar todos los LEDs de configuraciÃ³n por defecto
0001cd 982c                          cbi PORTB, LED_CONFIG_HORA       ; Apaga el LED de configuraciÃ³n de hora en PORTB
0001ce 982d                          cbi PORTB, LED_CONFIG_FECHA      ; Apaga el LED de configuraciÃ³n de fecha en PORTB
                                     
                                     ; Para el LED de alarma que estÃ¡ en PORTC, usar el registro sombra
0001cf 9100 0117                     lds temp, portc_shadow            ; Carga el estado actual guardado de PORTC en 'temp'
0001d1 7f0e                          andi temp, ~(1<<LED_CONFIG_ALARMA); Apaga el bit correspondiente al LED de alarma
0001d2 9300 0117                     sts portc_shadow, temp            ; Actualiza el registro sombra con el nuevo estado
                                     
                                     ; Si estamos en modo configuraciÃ³n hora (2), encender LED CONFIG_HORA
0001d4 9100 010f                     lds temp, modo_reloj              ; Recarga el modo actual despuÃ©s de modificar el registro sombra
0001d6 3002                          cpi temp, 2                       ; Compara el modo con 2
0001d7 f411                          brne CHECK_MODO_3                 ; Si no es igual, salta a CHECK_MODO_3
0001d8 9a2c                          sbi PORTB, LED_CONFIG_HORA        ; Enciende el LED de configuraciÃ³n de hora
0001d9 c00b                          rjmp CONTINUE_MODO_CHECK          ; Salta a CONTINUE_MODO_CHECK
                                     
                                 CHECK_MODO_3:
                                     ; Si estamos en modo configuraciÃ³n fecha (3), encender LED CONFIG_FECHA
0001da 3003                          cpi temp, 3                       ; Compara el modo con 3
0001db f411                          brne CHECK_MODO_4                 ; Si no es igual, salta a CHECK_MODO_4
0001dc 9a2d                          sbi PORTB, LED_CONFIG_FECHA       ; Enciende el LED de configuraciÃ³n de fecha
0001dd c007                          rjmp CONTINUE_MODO_CHECK          ; Salta a CONTINUE_MODO_CHECK
                                     
                                 CHECK_MODO_4:
                                     ; Si estamos en modo configuraciÃ³n alarma (4), encender LED CONFIG_ALARMA
0001de 3004                          cpi temp, 4                       ; Compara el modo con 4
0001df f429                          brne CONTINUE_MODO_CHECK          ; Si no es igual, salta a CONTINUE_MODO_CHECK
                                     
                                     ; Usar registro sombra para encender LED
0001e0 9100 0117                     lds temp, portc_shadow            ; Carga el estado actual guardado de PORTC en 'temp'
0001e2 6001                          ori temp, (1<<LED_CONFIG_ALARMA)  ; Enciende el bit correspondiente al LED de alarma
0001e3 9300 0117                     sts portc_shadow, temp            ; Guarda el nuevo estado en el registro sombra
                                     
                                 CONTINUE_MODO_CHECK:
                                     ; Si modo es 0 o 1, actualizar mostrar_fecha
0001e5 9100 010f                     lds temp, modo_reloj              ; Recarga el modo para comprobar
0001e7 3002                          cpi temp, 2                       ; Compara el modo con 2
0001e8 f418                          brsh SALTAR_A_EXIT                ; Si el modo es mayor o igual a 2, salta a SALTAR_A_EXIT
                                     
                                     ; Si es 0 o 1, mostrar_fecha = modo_reloj
0001e9 9300 010a                     sts mostrar_fecha, temp           ; Actualiza 'mostrar_fecha' con el valor de 'modo_reloj'
0001eb c06a                          rjmp PCINT0_EXIT                  ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 SALTAR_A_EXIT:
0001ec c069                          rjmp PCINT0_EXIT                  ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 CHECK_BOTONES_CONFIG:
                                     ; Verificar si estamos en modo configuraciÃ³n (2, 3 o 4)
0001ed 9100 010f                     lds temp, modo_reloj          ; Carga el modo actual en 'temp'
0001ef 3002                          cpi temp, 2                   ; Compara 'temp' con 2
0001f0 f031                          breq MODO_CONFIG_HORA         ; Si es modo 2, salta a MODO_CONFIG_HORA
0001f1 3003                          cpi temp, 3                   ; Compara 'temp' con 3
0001f2 f119                          breq MODO_CONFIG_FECHA        ; Si es modo 3, salta a MODO_CONFIG_FECHA
0001f3 3004                          cpi temp, 4                   ; Compara 'temp' con 4
0001f4 f009                          breq MODO_CONFIG_ALARMA_CHECK  ; Si es modo 4, salta a MODO_CONFIG_ALARMA_CHECK
0001f5 c060                          rjmp PCINT0_EXIT              ; Si no es ninguno de los modos de configuraciÃ³n, salir
                                     
                                 MODO_CONFIG_ALARMA_CHECK:
                                     ; Estamos en modo 4 (configuraciÃ³n alarma)
0001f6 c03f                          rjmp MODO_CONFIG_ALARMA       ; Salta a la rutina de configuraciÃ³n de alarma
                                 
                                 MODO_CONFIG_HORA:
                                     ; CÃ³digo original para modo 2 (configuraciÃ³n hora)
                                     ; Leer estado actual de los botones
0001f7 b103                          in temp, PINB                 ; Lee el estado de los botones en PORTB
                                     
                                     ; BotÃ³n SELECCIÃN (PB2)
0001f8 fd02                          sbrc temp, BOTON_SELECCION     ; Salta si el botÃ³n SELECCIÃN NO estÃ¡ presionado
0001f9 c007                          rjmp CHECK_BOTON_INCREMENTO    ; Si estÃ¡ presionado, salta a CHECK_BOTON_INCREMENTO
                                     
                                     ; El botÃ³n selecciÃ³n estÃ¡ presionado
0001fa 9100 0110                     lds temp, config_sel           ; Carga el estado de configuraciÃ³n en 'temp'
0001fc e011                          ldi temp2, 1                   ; Carga 1 en 'temp2'
0001fd 2701                          eor temp, temp2                ; Invierte el estado de 'config_sel' (0 a 1 o 1 a 0)
0001fe 9300 0110                     sts config_sel, temp           ; Guarda el nuevo estado de configuraciÃ³n
000200 c055                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                 
                                 CHECK_BOTON_INCREMENTO:
                                     ; BotÃ³n INCREMENTO (PB0)
000201 b103                          in temp, PINB                 ; Lee el estado de los botones en PORTB
000202 fd00                          sbrc temp, BOTON_INCREMENTO    ; Salta si el botÃ³n INCREMENTO NO estÃ¡ presionado
000203 c008                          rjmp CHECK_BOTON_DECREMENTO    ; Si estÃ¡ presionado, salta a CHECK_BOTON_DECREMENTO
                                     
                                     ; El botÃ³n incremento estÃ¡ presionado
000204 9100 0110                     lds temp, config_sel           ; Carga el estado de configuraciÃ³n en 'temp'
000206 3000                          cpi temp, 0                    ; Compara 'temp' con 0
000207 f411                          brne INC_MINUTOS_MANUAL       ; Si no es 0, salta a INC_MINUTOS_MANUAL
                                     
                                     ; Incrementar horas manualmente
000208 d1a3                          rcall INCREMENTAR_HORAS_MANUAL ; Llama a la subrutina para incrementar horas manualmente
000209 c04c                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 INC_MINUTOS_MANUAL:
                                     ; Incrementar minutos manualmente
00020a d179                          rcall INCREMENTAR_MINUTOS_MANUAL ; Llama a la subrutina para incrementar minutos manualmente
00020b c04a                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 CHECK_BOTON_DECREMENTO:
                                     ; BotÃ³n DECREMENTO (PB1)
00020c b103                          in temp, PINB                 ; Lee el estado de los botones en PORTB
00020d fd01                          sbrc temp, BOTON_DECREMENTO    ; Salta si el botÃ³n DECREMENTO NO estÃ¡ presionado
00020e c047                          rjmp PCINT0_EXIT               ; Si estÃ¡ presionado, salta a la salida de la rutina de interrupciÃ³n
                                     
                                     ; El botÃ³n decremento estÃ¡ presionado
00020f 9100 0110                     lds temp, config_sel           ; Carga el estado de configuraciÃ³n en 'temp'
000211 3000                          cpi temp, 0                    ; Compara 'temp' con 0
000212 f411                          brne DEC_MINUTOS_MANUAL       ; Si no es 0, salta a DEC_MINUTOS_MANUAL
                                     
                                     ; Decrementar horas manualmente
000213 d1b8                          rcall DECREMENTAR_HORAS_MANUAL ; Llama a la subrutina para decrementar horas manualmente
000214 c041                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 DEC_MINUTOS_MANUAL:
                                     ; Decrementar minutos manualmente
000215 d182                          rcall DECREMENTAR_MINUTOS_MANUAL ; Llama a la subrutina para decrementar minutos manualmente
                                 
                                 MODO_CONFIG_FECHA:
                                     ; Estamos en modo 3 (configuraciÃ³n fecha)
                                     ; Leer estado actual de los botones
000216 b103                          in temp, PINB                 ; Lee el estado de los botones en PORTB
                                     
                                     ; BotÃ³n SELECCIÃN (PB2)
000217 fd02                          sbrc temp, BOTON_SELECCION     ; Salta si el botÃ³n SELECCIÃN NO estÃ¡ presionado
000218 c007                          rjmp CHECK_FECHA_INCREMENTO    ; Si estÃ¡ presionado, salta a CHECK_FECHA_INCREMENTO
                                     
                                     ; El botÃ³n selecciÃ³n estÃ¡ presionado en modo 3
000219 9100 0110                     lds temp, config_sel           ; Carga el estado de configuraciÃ³n en 'temp'
00021b e011                          ldi temp2, 1                   ; Carga 1 en 'temp2'
00021c 2701                          eor temp, temp2                ; Invierte el estado de 'config_sel' (0 = dÃ­as, 1 = meses)
00021d 9300 0110                     sts config_sel, temp           ; Guarda el nuevo estado de configuraciÃ³n
00021f c036                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                 
                                 CHECK_FECHA_INCREMENTO:
                                     ; BotÃ³n INCREMENTO (PB0)
000220 b103                          in temp, PINB                 ; Lee el estado de los botones en PORTB
000221 fd00                          sbrc temp, BOTON_INCREMENTO    ; Salta si el botÃ³n INCREMENTO NO estÃ¡ presionado
000222 c008                          rjmp CHECK_FECHA_DECREMENTO    ; Si estÃ¡ presionado, salta a CHECK_FECHA_DECREMENTO
                                     
                                     ; El botÃ³n incremento estÃ¡ presionado
000223 9100 0110                     lds temp, config_sel           ; Carga el estado de configuraciÃ³n en 'temp'
000225 3000                          cpi temp, 0                    ; Compara 'temp' con 0
000226 f411                          brne INC_MESES_MANUAL         ; Si no es 0, salta a INC_MESES_MANUAL
                                     
                                     ; Incrementar dÃ­as manualmente
000227 d1d8                          rcall INCREMENTAR_DIAS_MANUAL  ; Llama a la subrutina para incrementar dÃ­as manualmente
000228 c02d                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 INC_MESES_MANUAL:
                                     ; Incrementar meses manualmente
000229 d22a                          rcall INCREMENTAR_MESES_MANUAL  ; Llama a la subrutina para incrementar meses manualmente
00022a c02b                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 CHECK_FECHA_DECREMENTO:
                                     ; BotÃ³n DECREMENTO (PB1)
00022b b103                          in temp, PINB                 ; Lee el estado de los botones en PORTB
00022c fd01                          sbrc temp, BOTON_DECREMENTO    ; Salta si el botÃ³n DECREMENTO NO estÃ¡ presionado
00022d c028                          rjmp PCINT0_EXIT               ; Si estÃ¡ presionado, salta a la salida de la rutina de interrupciÃ³n
                                     
                                     ; El botÃ³n decremento estÃ¡ presionado
00022e 9100 0110                     lds temp, config_sel           ; Carga el estado de configuraciÃ³n en 'temp'
000230 3000                          cpi temp, 0                    ; Compara 'temp' con 0
000231 f411                          brne DEC_MESES_MANUAL         ; Si no es 0, salta a DEC_MESES_MANUAL
                                     
                                     ; Decrementar dÃ­as manualmente
000232 d1ee                          rcall DECREMENTAR_DIAS_MANUAL  ; Llama a la subrutina para decrementar dÃ­as manualmente
000233 c022                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 DEC_MESES_MANUAL:
                                     ; Decrementar meses manualmente
000234 d26d                          rcall DECREMENTAR_MESES_MANUAL  ; Llama a la subrutina para decrementar meses manualmente
000235 c020                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                 
                                 MODO_CONFIG_ALARMA:
                                     ; Estamos en modo 4 (configuraciÃ³n alarma)
                                     ; Leer estado actual de los botones
000236 b103                          in temp, PINB                 ; Lee el estado de los botones en PORTB
                                     
                                     ; BotÃ³n SELECCIÃN (PB2)
000237 fd02                          sbrc temp, BOTON_SELECCION     ; Salta si el botÃ³n SELECCIÃN NO estÃ¡ presionado
000238 c007                          rjmp CHECK_ALARMA_INCREMENTO    ; Si estÃ¡ presionado, salta a CHECK_ALARMA_INCREMENTO
                                     
                                     ; El botÃ³n selecciÃ³n estÃ¡ presionado en modo 4
000239 9100 0110                     lds temp, config_sel           ; Carga el estado de configuraciÃ³n en 'temp'
00023b e011                          ldi temp2, 1                   ; Carga 1 en 'temp2'
00023c 2701                          eor temp, temp2                ; Invierte el estado de 'config_sel' (0 = horas, 1 = minutos)
00023d 9300 0110                     sts config_sel, temp           ; Guarda el nuevo estado de configuraciÃ³n
00023f c016                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                 
                                 CHECK_ALARMA_INCREMENTO:
                                     ; BotÃ³n INCREMENTO (PB0)
000240 b103                          in temp, PINB                 ; Lee el estado de los botones en PORTB
000241 fd00                          sbrc temp, BOTON_INCREMENTO    ; Salta si el botÃ³n INCREMENTO NO estÃ¡ presionado
000242 c008                          rjmp CHECK_ALARMA_DECREMENTO    ; Si estÃ¡ presionado, salta a CHECK_ALARMA_DECREMENTO
                                     
                                     ; El botÃ³n incremento estÃ¡ presionado
000243 9100 0110                     lds temp, config_sel           ; Carga el estado de configuraciÃ³n en 'temp'
000245 3000                          cpi temp, 0                    ; Compara 'temp' con 0
000246 f411                          brne INC_ALARMA_MINUTOS       ; Si no es 0, salta a INC_ALARMA_MINUTOS
                                     
                                     ; Incrementar horas de alarma
000247 d29d                          rcall INCREMENTAR_HORAS_ALARMA ; Llama a la subrutina para incrementar horas de alarma
000248 c00d                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 INC_ALARMA_MINUTOS:
                                     ; Incrementar minutos de alarma
000249 d2db                          rcall INCREMENTAR_MINUTOS_ALARMA ; Llama a la subrutina para incrementar minutos de alarma
00024a c00b                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 CHECK_ALARMA_DECREMENTO:
                                     ; BotÃ³n DECREMENTO (PB1)
00024b b103                          in temp, PINB                 ; Lee el estado de los botones en PORTB
00024c fd01                          sbrc temp, BOTON_DECREMENTO    ; Salta si el botÃ³n DECREMENTO NO estÃ¡ presionado
00024d c008                          rjmp PCINT0_EXIT               ; Si estÃ¡ presionado, salta a la salida de la rutina de interrupciÃ³n
                                     
                                     ; El botÃ³n decremento estÃ¡ presionado
00024e 9100 0110                     lds temp, config_sel           ; Carga el estado de configuraciÃ³n en 'temp'
000250 3000                          cpi temp, 0                    ; Compara 'temp' con 0
000251 f411                          brne DEC_ALARMA_MINUTOS       ; Si no es 0, salta a DEC_ALARMA_MINUTOS
                                     
                                     ; Decrementar horas de alarma
000252 d2b5                          rcall DECREMENTAR_HORAS_ALARMA ; Llama a la subrutina para decrementar horas de alarma
000253 c002                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                     
                                 DEC_ALARMA_MINUTOS:
                                     ; Decrementar minutos de alarma
000254 d2e7                          rcall DECREMENTAR_MINUTOS_ALARMA ; Llama a la subrutina para decrementar minutos de alarma
000255 c000                          rjmp PCINT0_EXIT               ; Salta a la salida de la rutina de interrupciÃ³n
                                 
                                 PCINT0_EXIT:
                                     ; Restaura contexto
000256 911f                          pop temp2                      ; Restaura el registro 'temp2' de la pila
000257 910f                          pop temp                       ; Restaura el registro 'temp' de la pila
000258 bf0f                          out SREG, temp                 ; Restaura el registro de estado (SREG)
000259 910f                          pop temp                       ; Restaura el registro 'temp' de la pila
00025a 9518                          reti                           ; Retorna de la interrupciÃ³n
                                 
                                 ;***********************************************
                                 ; RUTINA DE INTERRUPCIÃN DEL TIMER0
                                 ;***********************************************
                                 TMR0_ISR:
                                     ; Guarda contexto
00025b 930f                          push temp                   ; Guarda el registro 'temp' en la pila
00025c b70f                          in temp, SREG               ; Lee el registro de estado (SREG) y lo guarda en 'temp'
00025d 930f                          push temp                   ; Guarda el registro de estado en la pila
00025e 931f                          push temp2                  ; Guarda el registro 'temp2' en la pila
00025f 93ef                          push ZL                     ; Guarda la parte baja del registro Z en la pila
000260 93ff                          push ZH                     ; Guarda la parte alta del registro Z en la pila
                                 
000261 9100 0116                     lds temp, alarma_sonando    ; Carga el estado de la alarma en 'temp'
000263 3001                          cpi temp, 1                 ; Compara 'temp' con 1 (alarma sonando)
000264 f431                          brne CONTINUE_TMR0         ; Si no estÃ¡ sonando, salta a CONTINUE_TMR0
                                     
                                     ; Toggle el bit del buzzer en portc_shadow
000265 9100 0117                     lds temp, portc_shadow      ; Carga el estado actual guardado de PORTC en 'temp'
000267 e012                          ldi temp2, (1 << BUZZER)    ; Carga el bit correspondiente al buzzer en 'temp2'
000268 2701                          eor temp, temp2             ; Invierte el estado del buzzer (toggle)
000269 9300 0117                     sts portc_shadow, temp      ; Actualiza el registro sombra con el nuevo estado
                                 
                                     ;out PORTC, temp            ; IMPORTANTE: Actualiza el puerto fÃ­sico (comentado)
                                 
                                 CONTINUE_TMR0:  
                                     ; Incrementa contador para parpadeo de LEDs
00026b 9100 010d                     lds temp, led_counter        ; Carga el contador de LEDs en 'temp'
00026d 9503                          inc temp                     ; Incrementa el contador
00026e 9300 010d                     sts led_counter, temp        ; Guarda el nuevo valor del contador
                                     
000270 e11e                          ldi temp2, 30                ; Carga 30 en 'temp2' (aproximadamente 500ms)
000271 1701                          cp temp, temp2              ; Compara el contador de LEDs con 30
000272 f491                          brne SKIP_LED_TOGGLE        ; Si no es igual, salta a SKIP_LED_TOGGLE
                                     
                                     ; Reinicia contador de LEDs
000273 e000                          ldi temp, 0                  ; Carga 0 en 'temp'
000274 9300 010d                     sts led_counter, temp        ; Reinicia el contador de LEDs
                                     
                                     ; Invierte estado de los LEDs en PD7
000276 9100 010e                     lds temp, led_state          ; Carga el estado actual de los LEDs en 'temp'
000278 e011                          ldi temp2, 1                 ; Carga 1 en 'temp2'
000279 2701                          eor temp, temp2              ; Invierte el bit 0 del estado de los LEDs
00027a 9300 010e                     sts led_state, temp          ; Guarda el nuevo estado de los LEDs
                                     
                                     ; Aplicar estado a los LEDs
00027c 3000                          cpi temp, 0                  ; Compara el estado de los LEDs con 0
00027d f021                          breq LEDS_OFF                ; Si es 0, salta a LEDS_OFF
                                     
                                     ; Encender LEDs (PD7)
00027e b10b                          in temp, PORTD              ; Lee el estado actual de PORTD
00027f 6800                          ori temp, (1<<LED_BIT)      ; Enciende el bit correspondiente a los LEDs
000280 b90b                          out PORTD, temp             ; Actualiza el puerto D con el nuevo estado
000281 c003                          rjmp SKIP_LED_TOGGLE        ; Salta a SKIP_LED_TOGGLE
                                     
                                 LEDS_OFF:
                                     ; Apagar LEDs (PD7)
000282 b10b                          in temp, PORTD              ; Lee el estado actual de PORTD
000283 770f                          andi temp, ~(1<<LED_BIT)    ; Apaga el bit correspondiente a los LEDs
000284 b90b                          out PORTD, temp             ; Actualiza el puerto D con el nuevo estado
                                     
                                 SKIP_LED_TOGGLE:
                                     ; Verificar si estamos en modo configuraciÃ³n
000285 9100 010f                     lds temp, modo_reloj        ; Carga el modo actual en 'temp'
000287 3002                          cpi temp, 2                 ; Compara 'temp' con 2
000288 f061                          breq TMR0_EXIT              ; Si estamos en modo configuraciÃ³n, salta a TMR0_EXIT
                                     
                                     ; ContinÃºa con el contador de tiempo normal solo si NO estamos en configuraciÃ³n
000289 9100 0100                     lds temp, timer_count       ; Carga el contador de tiempo en 'temp'
00028b 9503                          inc temp                    ; Incrementa el contador
00028c 9300 0100                     sts timer_count, temp       ; Guarda el nuevo valor del contador
                                     
00028e e31c                          ldi temp2, VALOR_COMPARACION ; Carga el valor de comparaciÃ³n (aproximadamente 1 segundo)
00028f 1701                          cp temp, temp2             ; Compara el contador de tiempo con el valor de comparaciÃ³n
000290 f421                          brne TMR0_EXIT              ; Si no es igual, salta a TMR0_EXIT
                                     
                                     ; Reinicia contador y maneja tiempo
000291 e000                          ldi temp, 0                  ; Carga 0 en 'temp'
000292 9300 0100                     sts timer_count, temp        ; Reinicia el contador de tiempo
000294 d007                          rcall INCREMENTAR_SEGUNDOS   ; Llama a la subrutina para incrementar los segundos
                                 
                                 TMR0_EXIT:
                                     ; Restaura contexto
000295 91ff                          pop ZH                       ; Restaura la parte alta del registro Z de la pila
000296 91ef                          pop ZL                       ; Restaura la parte baja del registro Z de la pila
000297 911f                          pop temp2                    ; Restaura el registro 'temp2' de la pila
000298 910f                          pop temp                     ; Restaura el registro 'temp' de la pila
000299 bf0f                          out SREG, temp               ; Restaura el registro de estado (SREG)
00029a 910f                          pop temp                     ; Restaura el registro 'temp' de la pila
00029b 9518                          reti                         ; Retorna de la interrupciÃ³n
                                 
                                 ;***********************************************
                                 ; SUBRUTINAS DE MANEJO DE TIEMPO
                                 ;***********************************************
                                 ;----------------------------------------------
                                 ; INCREMENTAR_SEGUNDOS: Incrementa segundos y actualiza tiempo
                                 ;----------------------------------------------
                                 INCREMENTAR_SEGUNDOS:
00029c 9100 0101                     lds temp, segundos            ; Carga el valor actual de segundos en 'temp'
00029e 9503                          inc temp                      ; Incrementa el contador de segundos
00029f 9300 0101                     sts segundos, temp            ; Guarda el nuevo valor de segundos
                                     
0002a1 330c                          cpi temp, 60                  ; Compara 'temp' con 60
0002a2 f429                          brne CHECK_ALARMA             ; Si no es 60, salta a CHECK_ALARMA
                                     
                                     ; Si pasaron 60 segundos, incrementar minutos
0002a3 e000                          ldi temp, 0                   ; Carga 0 en 'temp' para reiniciar segundos
0002a4 9300 0101                     sts segundos, temp            ; Reinicia el contador de segundos
0002a6 d025                          rcall INCREMENTAR_MINUTOS     ; Llama a la subrutina para incrementar minutos
0002a7 c000                          rjmp CHECK_ALARMA             ; Salta incondicionalmente a CHECK_ALARMA
                                     
                                 CHECK_ALARMA:
                                     ; Verificar si la alarma estÃ¡ activa
0002a8 9100 0115                     lds temp, alarma_activa       ; Carga el estado de la alarma activa en 'temp'
0002aa 3001                          cpi temp, 1                   ; Compara 'temp' con 1 (alarma activa)
0002ab f4f9                          brne EXIT_INC_SEGUNDOS        ; Si la alarma no estÃ¡ activa, salir
                                     
                                     ; Obtener el estado actual de alarma_sonando
0002ac 9100 0116                     lds temp, alarma_sonando      ; Carga el estado de la alarma sonando en 'temp'
0002ae 3001                          cpi temp, 1                   ; Compara 'temp' con 1 (alarma sonando)
0002af f0d9                          breq EXIT_INC_SEGUNDOS        ; Si ya estÃ¡ sonando, salir
                                     
                                     ; Comparar hora y minutos
0002b0 9100 0105                     lds temp, hora_decenas        ; Carga las decenas de la hora en 'temp'
0002b2 9110 0112                     lds temp2, alarma_hora_decenas; Carga las decenas de la alarma en 'temp2'
0002b4 1701                          cp temp, temp2                ; Compara las decenas de la hora con las de la alarma
0002b5 f4a9                          brne EXIT_INC_SEGUNDOS        ; Si no son iguales, salir
                                     
0002b6 9100 0104                     lds temp, hora_unidades       ; Carga las unidades de la hora en 'temp'
0002b8 9110 0111                     lds temp2, alarma_hora_unidades; Carga las unidades de la alarma en 'temp2'
0002ba 1701                          cp temp, temp2                ; Compara las unidades de la hora con las de la alarma
0002bb f479                          brne EXIT_INC_SEGUNDOS        ; Si no son iguales, salir
                                     
0002bc 9100 0103                     lds temp, min_decenas         ; Carga las decenas de minutos en 'temp'
0002be 9110 0114                     lds temp2, alarma_min_decenas ; Carga las decenas de minutos de la alarma en 'temp2'
0002c0 1701                          cp temp, temp2                ; Compara las decenas de minutos
0002c1 f449                          brne EXIT_INC_SEGUNDOS        ; Si no son iguales, salir
                                     
0002c2 9100 0102                     lds temp, min_unidades        ; Carga las unidades de minutos en 'temp'
0002c4 9110 0113                     lds temp2, alarma_min_unidades; Carga las unidades de minutos de la alarma en 'temp2'
0002c6 1701                          cp temp, temp2                ; Compara las unidades de minutos
0002c7 f419                          brne EXIT_INC_SEGUNDOS        ; Si no son iguales, salir
                                     
                                     ; Si todas las condiciones se cumplen, activar la alarma
0002c8 e001                          ldi temp, 1                   ; Carga 1 en 'temp' para activar la alarma
0002c9 9300 0116                     sts alarma_sonando, temp      ; Establece el estado de la alarma como sonando
                                     
                                 EXIT_INC_SEGUNDOS:
0002cb 9508                          ret                            ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_MINUTOS: Incrementa minutos
                                 ;----------------------------------------------
                                 INCREMENTAR_MINUTOS:
0002cc 9100 0102                     lds temp, min_unidades        ; Carga el valor actual de las unidades de minutos en 'temp'
0002ce 9503                          inc temp                      ; Incrementa el contador de minutos
0002cf 9300 0102                     sts min_unidades, temp        ; Guarda el nuevo valor de las unidades de minutos
                                     
0002d1 300a                          cpi temp, 10                  ; Compara 'temp' con 10
0002d2 f421                          brne EXIT_INC_MINUTOS        ; Si no es 10, salir
                                     
                                     ; Si las unidades llegaron a 10
0002d3 e000                          ldi temp, 0                   ; Carga 0 en 'temp' para reiniciar las unidades de minutos
0002d4 9300 0102                     sts min_unidades, temp        ; Reinicia las unidades de minutos
0002d6 d001                          rcall INCREMENTAR_MIN_DECENAS ; Llama a la subrutina para incrementar las decenas de minutos
                                     
                                 EXIT_INC_MINUTOS:
0002d7 9508                          ret                            ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_MIN_DECENAS: Incrementa decenas de minutos
                                 ;----------------------------------------------
                                 INCREMENTAR_MIN_DECENAS:
0002d8 9100 0103                     lds temp, min_decenas         ; Carga el valor actual de las decenas de minutos en 'temp'
0002da 9503                          inc temp                      ; Incrementa el contador de decenas de minutos
0002db 9300 0103                     sts min_decenas, temp         ; Guarda el nuevo valor de las decenas de minutos
                                     
0002dd 3006                          cpi temp, 6                   ; Compara 'temp' con 6
0002de f421                          brne EXIT_INC_MIN_DECENAS     ; Si no es 6, salta a EXIT_INC_MIN_DECENAS
                                     
                                     ; Si las decenas llegaron a 6 (60 minutos)
0002df e000                          ldi temp, 0                   ; Carga 0 en 'temp' para reiniciar las decenas de minutos
0002e0 9300 0103                     sts min_decenas, temp         ; Reinicia las decenas de minutos
0002e2 d001                          rcall INCREMENTAR_HORAS       ; Llama a la subrutina para incrementar las horas
                                     
                                 EXIT_INC_MIN_DECENAS:
0002e3 9508                          ret                            ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_HORAS: Incrementa horas
                                 ;----------------------------------------------
                                 INCREMENTAR_HORAS:
0002e4 9100 0104                     lds temp, hora_unidades        ; Carga el valor actual de las unidades de horas en 'temp'
0002e6 9503                          inc temp                       ; Incrementa el contador de horas
0002e7 9300 0104                     sts hora_unidades, temp        ; Guarda el nuevo valor de las unidades de horas
                                     
0002e9 300a                          cpi temp, 10                   ; Compara 'temp' con 10
0002ea f449                          brne CHECK_24_HORAS           ; Si no es 10, salta a CHECK_24_HORAS
                                     
                                     ; Si las unidades llegaron a 10
0002eb e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar las unidades de horas
0002ec 9300 0104                     sts hora_unidades, temp        ; Reinicia las unidades de horas
                                     
0002ee 9100 0105                     lds temp, hora_decenas         ; Carga el valor actual de las decenas de horas en 'temp'
0002f0 9503                          inc temp                       ; Incrementa el contador de decenas de horas
0002f1 9300 0105                     sts hora_decenas, temp         ; Guarda el nuevo valor de las decenas de horas
0002f3 9508                          ret                             ; Retorna de la subrutina
                                     
                                 CHECK_24_HORAS:
                                     ; Verifica si llegamos a 24 horas
0002f4 9100 0105                     lds temp, hora_decenas         ; Carga el valor actual de las decenas de horas en 'temp'
0002f6 3002                          cpi temp, 2                    ; Compara 'temp' con 2
0002f7 f451                          brne EXIT_INC_HORAS            ; Si no es 2, salta a EXIT_INC_HORAS
                                     
0002f8 9100 0104                     lds temp, hora_unidades        ; Carga el valor actual de las unidades de horas en 'temp'
0002fa 3004                          cpi temp, 4                    ; Compara 'temp' con 4 (24 horas)
0002fb f431                          brne EXIT_INC_HORAS            ; Si no es 4, salta a EXIT_INC_HORAS
                                     
                                     ; Reinicia el reloj a 00:00
0002fc e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar las horas
0002fd 9300 0104                     sts hora_unidades, temp        ; Reinicia las unidades de horas
0002ff 9300 0105                     sts hora_decenas, temp         ; Reinicia las decenas de horas
                                     
                                     ; Ahora incrementa el dÃ­a al pasar 24 horas
000301 d001                          rcall INCREMENTAR_DIA          ; Llama a la subrutina para incrementar el dÃ­a
                                     
                                 EXIT_INC_HORAS:
000302 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_DIA: Incrementa dÃ­as y maneja cambios de mes
                                 ;----------------------------------------------
                                 INCREMENTAR_DIA:
                                     ; Incrementa el dÃ­a
000303 9100 0106                     lds temp, dia_unidades         ; Carga el valor actual de las unidades de dÃ­a en 'temp'
000305 9503                          inc temp                       ; Incrementa el contador de dÃ­as
000306 9300 0106                     sts dia_unidades, temp         ; Guarda el nuevo valor de las unidades de dÃ­a
                                     
000308 300a                          cpi temp, 10                   ; Compara 'temp' con 10
000309 f441                          brne CHECK_LIMITE_DIA         ; Si no es 10, salta a CHECK_LIMITE_DIA
                                     
                                     ; Si las unidades llegaron a 10
00030a e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar las unidades de dÃ­a
00030b 9300 0106                     sts dia_unidades, temp         ; Reinicia las unidades de dÃ­a
                                     
                                     ; Incrementa decenas de dÃ­a
00030d 9100 0107                     lds temp, dia_decenas          ; Carga el valor actual de las decenas de dÃ­a en 'temp'
00030f 9503                          inc temp                       ; Incrementa el contador de decenas de dÃ­a
000310 9300 0107                     sts dia_decenas, temp          ; Guarda el nuevo valor de las decenas de dÃ­a
                                     
                                 CHECK_LIMITE_DIA:
                                     ; Verifica quÃ© mes es para saber el lÃ­mite de dÃ­as
000312 9100 0109                     lds temp, mes_decenas          ; Carga el valor de las decenas del mes en 'temp'
000314 3000                          cpi temp, 0                    ; Compara 'temp' con 0
000315 f459                          brne CHECK_OCTUBRE_DICIEMBRE   ; Si es 1, salta a CHECK_OCTUBRE_DICIEMBRE
                                     
                                     ; Para meses del 1 al 9
000316 9100 0108                     lds temp, mes_unidades         ; Carga el valor de las unidades del mes en 'temp'
000318 3002                          cpi temp, 2                    ; Compara con 2 (Febrero)
000319 f061                          breq FEBRERO                   ; Si es Febrero, salta a la rutina de manejo de Febrero
                                     
00031a 3004                          cpi temp, 4                    ; Compara con 4 (Abril)
00031b f111                          breq MES_30_DIAS               ; Si es Abril, salta a la rutina de 30 dÃ­as
                                     
00031c 3006                          cpi temp, 6                    ; Compara con 6 (Junio)
00031d f101                          breq MES_30_DIAS               ; Si es Junio, salta a la rutina de 30 dÃ­as
                                     
00031e 3009                          cpi temp, 9                    ; Compara con 9 (Septiembre)
00031f f0f1                          breq MES_30_DIAS               ; Si es Septiembre, salta a la rutina de 30 dÃ­as
                                     
                                     ; Meses de 31 dÃ­as (Enero, Marzo, Mayo, Julio, Agosto)
000320 c035                          rjmp MES_31_DIAS               ; Salta a la rutina de 31 dÃ­as
                                     
                                 CHECK_OCTUBRE_DICIEMBRE:
000321 9100 0108                     lds temp, mes_unidades         ; Carga el valor de las unidades del mes en 'temp'
000323 3001                          cpi temp, 1                    ; Compara con 1 (Noviembre)
000324 f0c9                          breq MES_30_DIAS               ; Si es Noviembre, salta a la rutina de 30 dÃ­as
                                     
                                     ; Meses de 31 dÃ­as (Octubre y Diciembre)
000325 c030                          rjmp MES_31_DIAS               ; Salta a la rutina de 31 dÃ­as
                                     
                                 FEBRERO:
                                     ; Febrero tiene 28 dÃ­as (no implementamos aÃ±os bisiestos)
000326 9100 0107                     lds temp, dia_decenas          ; Carga el valor de las decenas de dÃ­a en 'temp'
000328 3002                          cpi temp, 2                    ; Compara con 2 (dÃ­as 20-29)
000329 f459                          brne CHECK_FEBRERO_UNIDADES    ; Si no es 2, salta a CHECK_FEBRERO_UNIDADES
                                     
00032a 9100 0106                     lds temp, dia_unidades         ; Carga el valor de las unidades de dÃ­a en 'temp'
00032c 3009                          cpi temp, 9                    ; Compara con 9 (dÃ­a 29)
00032d f5b9                          brne EXIT_INCREMENTAR_DIA      ; Si no es 29, salir
                                     
                                     ; Reinicia a dÃ­a 1 e incrementa mes
00032e e001                          ldi temp, 1                    ; Carga 1 en 'temp' para reiniciar el dÃ­a
00032f 9300 0106                     sts dia_unidades, temp         ; Establece el dÃ­a a 1
000331 e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar decenas de dÃ­a
000332 9300 0107                     sts dia_decenas, temp          ; Establece las decenas de dÃ­a a 0
000334 c031                          rjmp INCREMENTAR_MES           ; Llama a la subrutina para incrementar el mes
                                     
                                 CHECK_FEBRERO_UNIDADES:
000335 3003                          cpi temp, 3                    ; Compara con 3 (se pasÃ³ de 28)
000336 f571                          brne EXIT_INCREMENTAR_DIA      ; Si no es 3, salir
                                     
                                     ; Reinicia a dÃ­a 1 e incrementa mes
000337 e001                          ldi temp, 1                    ; Carga 1 en 'temp' para reiniciar el dÃ­a
000338 9300 0106                     sts dia_unidades, temp         ; Establece el dÃ­a a 1
00033a e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar decenas de dÃ­a
00033b 9300 0107                     sts dia_decenas, temp          ; Establece las decenas de dÃ­a a 0
00033d c028                          rjmp INCREMENTAR_MES           ; Llama a la subrutina para incrementar el mes
                                     
                                 MES_30_DIAS:
                                     ; Verifica si llegamos a 31 (dÃ­a 31)
00033e 9100 0107                     lds temp, dia_decenas          ; Carga el valor de las decenas de dÃ­a en 'temp'
000340 3003                          cpi temp, 3                    ; Compara con 3 (dÃ­as 30-31)
000341 f459                          brne CHECK_30_DIAS_UNIDADES     ; Si no es 3, salta a CHECK_30_DIAS_UNIDADES
                                     
000342 9100 0106                     lds temp, dia_unidades         ; Carga el valor de las unidades de dÃ­a en 'temp'
000344 3001                          cpi temp, 1                    ; Compara con 1 (dÃ­a 31)
000345 f4f9                          brne EXIT_INCREMENTAR_DIA      ; Si no es 31, salir
                                     
                                     ; Reinicia a dÃ­a 1 e incrementa mes
000346 e001                          ldi temp, 1                    ; Carga 1 en 'temp' para reiniciar el dÃ­a
000347 9300 0106                     sts dia_unidades, temp         ; Establece el dÃ­a a 1
000349 e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar decenas de dÃ­a
00034a 9300 0107                     sts dia_decenas, temp          ; Establece las decenas de dÃ­a a 0
00034c c019                          rjmp INCREMENTAR_MES           ; Llama a la subrutina para incrementar el mes
                                     
                                 CHECK_30_DIAS_UNIDADES:
00034d 3004                          cpi temp, 4                    ; Compara con 4 (se pasÃ³ de 30)
00034e f4b1                          brne EXIT_INCREMENTAR_DIA      ; Si no es 4, salir
                                     
                                     ; Reinicia a dÃ­a 1 e incrementa mes
00034f e001                          ldi temp, 1                    ; Carga 1 en 'temp' para reiniciar el dÃ­a
000350 9300 0106                     sts dia_unidades, temp         ; Establece el dÃ­a a 1
000352 e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar decenas de dÃ­a
000353 9300 0107                     sts dia_decenas, temp          ; Establece las decenas de dÃ­a a 0
000355 c010                          rjmp INCREMENTAR_MES           ; Llama a la subrutina para incrementar el mes
                                     
                                 MES_31_DIAS:
                                     ; Verifica si llegamos a 32 (dÃ­a 32)
000356 9100 0107                     lds temp, dia_decenas          ; Carga el valor de las decenas de dÃ­a en 'temp'
000358 3003                          cpi temp, 3                    ; Compara con 3 (dÃ­as 31-32)
000359 f459                          brne EXIT_INCREMENTAR_DIA      ; Si no es 3, salir
                                     
00035a 9100 0106                     lds temp, dia_unidades         ; Carga el valor de las unidades de dÃ­a en 'temp'
00035c 3002                          cpi temp, 2                    ; Compara con 2 (dÃ­a 32)
00035d f439                          brne EXIT_INCREMENTAR_DIA      ; Si no es 32, salir
                                     
                                     ; Reinicia a dÃ­a 1 e incrementa mes
00035e e001                          ldi temp, 1                    ; Carga 1 en 'temp' para reiniciar el dÃ­a
00035f 9300 0106                     sts dia_unidades, temp         ; Establece el dÃ­a a 1
000361 e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar decenas de dÃ­a
000362 9300 0107                     sts dia_decenas, temp          ; Establece las decenas de dÃ­a a 0
000364 c001                          rjmp INCREMENTAR_MES           ; Llama a la subrutina para incrementar el mes
                                     
                                 EXIT_INCREMENTAR_DIA:
000365 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_MES: Incrementa el mes y maneja cambio de aÃ±o
                                 ;----------------------------------------------
                                 INCREMENTAR_MES:
000366 9100 0108                     lds temp, mes_unidades         ; Carga el valor actual de las unidades del mes en 'temp'
000368 9503                          inc temp                       ; Incrementa el contador de unidades del mes
000369 9300 0108                     sts mes_unidades, temp         ; Guarda el nuevo valor de las unidades del mes
                                     
00036b 300a                          cpi temp, 10                   ; Compara 'temp' con 10
00036c f441                          brne CHECK_LIMITE_MES         ; Si no es 10, salta a CHECK_LIMITE_MES
                                     
                                     ; Si las unidades llegaron a 10
00036d e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar las unidades del mes
00036e 9300 0108                     sts mes_unidades, temp         ; Reinicia las unidades del mes
                                     
                                     ; Incrementa decenas de mes
000370 9100 0109                     lds temp, mes_decenas          ; Carga el valor actual de las decenas del mes en 'temp'
000372 9503                          inc temp                       ; Incrementa el contador de decenas del mes
000373 9300 0109                     sts mes_decenas, temp          ; Guarda el nuevo valor de las decenas del mes
                                     
                                 CHECK_LIMITE_MES:
                                     ; Verifica si llegamos a mes 13
000375 9100 0109                     lds temp, mes_decenas          ; Carga el valor actual de las decenas del mes en 'temp'
000377 3001                          cpi temp, 1                    ; Compara 'temp' con 1
000378 f451                          brne EXIT_INCREMENTAR_MES      ; Si no es 1, salta a EXIT_INCREMENTAR_MES
                                     
000379 9100 0108                     lds temp, mes_unidades         ; Carga el valor actual de las unidades del mes en 'temp'
00037b 3003                          cpi temp, 3                    ; Compara 'temp' con 3 (mes 13)
00037c f431                          brne EXIT_INCREMENTAR_MES      ; Si no es 3, salta a EXIT_INCREMENTAR_MES
                                     
                                     ; Reinicia a mes 1 (Enero)
00037d e001                          ldi temp, 1                    ; Carga 1 en 'temp' para establecer el mes a Enero
00037e 9300 0108                     sts mes_unidades, temp         ; Establece las unidades del mes a 1
000380 e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar las decenas del mes
000381 9300 0109                     sts mes_decenas, temp          ; Establece las decenas del mes a 0
                                     
                                     ; AquÃ­ podrÃ­a incrementarse el aÃ±o si se implementara
                                     
                                 EXIT_INCREMENTAR_MES:
000383 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_MINUTOS_MANUAL: Incrementa minutos manualmente (para configuraciÃ³n)
                                 ;----------------------------------------------
                                 INCREMENTAR_MINUTOS_MANUAL:
000384 9100 0102                     lds temp, min_unidades         ; Carga el valor actual de las unidades de minutos en 'temp'
000386 9503                          inc temp                       ; Incrementa el contador de unidades de minutos
000387 300a                          cpi temp, 10                   ; Compara 'temp' con 10
000388 f461                          brne SAVE_MIN_UNIT_INC         ; Si no es 10, salta a SAVE_MIN_UNIT_INC
                                     
                                     ; Si llegÃ³ a 10, resetear unidades e incrementar decenas
000389 e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar las unidades de minutos
00038a 9300 0102                     sts min_unidades, temp         ; Reinicia las unidades de minutos
                                     
00038c 9100 0103                     lds temp, min_decenas          ; Carga el valor actual de las decenas de minutos en 'temp'
00038e 9503                          inc temp                       ; Incrementa el contador de decenas de minutos
00038f 3006                          cpi temp, 6                    ; Compara 'temp' con 6
000390 f409                          brne SAVE_MIN_DEC_INC          ; Si no es 6, salta a SAVE_MIN_DEC_INC
                                     
                                     ; Si llegÃ³ a 6, resetear decenas
000391 e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar las decenas de minutos
                                     
                                 SAVE_MIN_DEC_INC:
000392 9300 0103                     sts min_decenas, temp          ; Guarda el nuevo valor de las decenas de minutos
000394 9508                          ret                             ; Retorna de la subrutina
                                     
                                 SAVE_MIN_UNIT_INC:
000395 9300 0102                     sts min_unidades, temp         ; Guarda el nuevo valor de las unidades de minutos
000397 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; DECREMENTAR_MINUTOS_MANUAL: Decrementa minutos manualmente (para configuraciÃ³n)
                                 ;----------------------------------------------
                                 DECREMENTAR_MINUTOS_MANUAL:
000398 9100 0102                     lds temp, min_unidades         ; Carga el valor actual de las unidades de minutos en 'temp'
00039a 3000                          cpi temp, 0                    ; Compara 'temp' con 0
00039b f461                          brne DEC_MIN_UNIT              ; Si no es 0, salta a DEC_MIN_UNIT
                                     
                                     ; Si era 0, poner a 9 y decrementar decenas
00039c e009                          ldi temp, 9                    ; Carga 9 en 'temp' para establecer las unidades de minutos
00039d 9300 0102                     sts min_unidades, temp         ; Establece las unidades de minutos a 9
                                     
00039f 9100 0103                     lds temp, min_decenas          ; Carga el valor actual de las decenas de minutos en 'temp'
0003a1 3000                          cpi temp, 0                    ; Compara 'temp' con 0
0003a2 f409                          brne DEC_MIN_DEC               ; Si no es 0, salta a DEC_MIN_DEC
                                     
                                     ; Si decenas era 0, poner a 5
0003a3 e006                          ldi temp, 6                    ; Carga 6 en 'temp' para establecer las decenas de minutos a 6
                                     
                                 DEC_MIN_DEC:
0003a4 950a                          dec temp                       ; Decrementa el contador de decenas de minutos
0003a5 9300 0103                     sts min_decenas, temp          ; Guarda el nuevo valor de las decenas de minutos
0003a7 9508                          ret                             ; Retorna de la subrutina
                                     
                                 DEC_MIN_UNIT:
0003a8 950a                          dec temp                       ; Decrementa el contador de unidades de minutos
0003a9 9300 0102                     sts min_unidades, temp         ; Guarda el nuevo valor de las unidades de minutos
0003ab 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_HORAS_MANUAL: Incrementa horas manualmente (para configuraciÃ³n)
                                 ;----------------------------------------------
                                 INCREMENTAR_HORAS_MANUAL:
0003ac 9100 0104                     lds temp, hora_unidades         ; Carga el valor actual de las unidades de horas en 'temp'
0003ae 9503                          inc temp                        ; Incrementa el contador de unidades de horas
0003af 300a                          cpi temp, 10                    ; Compara 'temp' con 10
0003b0 f461                          brne CHECK_MAX_HORA_INC         ; Si no es 10, salta a CHECK_MAX_HORA_INC
                                     
                                     ; Si llegÃ³ a 10, resetear unidades e incrementar decenas
0003b1 e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las unidades de horas
0003b2 9300 0104                     sts hora_unidades, temp         ; Reinicia las unidades de horas
                                     
0003b4 9100 0105                     lds temp, hora_decenas          ; Carga el valor actual de las decenas de horas en 'temp'
0003b6 9503                          inc temp                        ; Incrementa el contador de decenas de horas
0003b7 3003                          cpi temp, 3                     ; MÃ¡ximo 2 para formato 24h
0003b8 f409                          brne SAVE_HORA_DEC_INC          ; Si no es 3, salta a SAVE_HORA_DEC_INC
                                     
                                     ; Si llegÃ³ a 3, resetear decenas
0003b9 e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las decenas de horas
                                     
                                 SAVE_HORA_DEC_INC:
0003ba 9300 0105                     sts hora_decenas, temp          ; Guarda el nuevo valor de las decenas de horas
0003bc 9508                          ret                              ; Retorna de la subrutina
                                     
                                 CHECK_MAX_HORA_INC:
                                     ; Verificar si superamos 23 horas
0003bd 9110 0105                     lds temp2, hora_decenas         ; Carga el valor actual de las decenas de horas en 'temp2'
0003bf 3012                          cpi temp2, 2                    ; Compara 'temp2' con 2
0003c0 f441                          brne SAVE_HORA_UNIT_INC         ; Si no es 2, salta a SAVE_HORA_UNIT_INC
                                     
                                     ; Si decenas es 2, unidades no puede ser mayor que 3
0003c1 3004                          cpi temp, 4                     ; Compara 'temp' con 4
0003c2 f030                          brlo SAVE_HORA_UNIT_INC         ; Si es menor que 4, salta a SAVE_HORA_UNIT_INC
                                     
                                     ; Si llegÃ³ a 24, resetear a 00
0003c3 e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las unidades de horas
0003c4 9300 0104                     sts hora_unidades, temp         ; Establece las unidades de horas a 0
0003c6 9300 0105                     sts hora_decenas, temp          ; Establece las decenas de horas a 0
0003c8 9508                          ret                              ; Retorna de la subrutina
                                     
                                 SAVE_HORA_UNIT_INC:
0003c9 9300 0104                     sts hora_unidades, temp         ; Guarda el nuevo valor de las unidades de horas
0003cb 9508                          ret                              ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; DECREMENTAR_HORAS_MANUAL: Decrementa horas manualmente (para configuraciÃ³n)
                                 ;----------------------------------------------
                                 DECREMENTAR_HORAS_MANUAL:
0003cc 9100 0104                     lds temp, hora_unidades         ; Carga el valor actual de las unidades de horas en 'temp'
0003ce 3000                          cpi temp, 0                     ; Compara 'temp' con 0
0003cf f491                          brne DEC_HORA_UNIT              ; Si no es 0, salta a DEC_HORA_UNIT
                                     
                                     ; Si unidades era 0
0003d0 9110 0105                     lds temp2, hora_decenas         ; Carga el valor actual de las decenas de horas en 'temp2'
0003d2 3010                          cpi temp2, 0                    ; Compara 'temp2' con 0
0003d3 f439                          brne DEC_DESDE_X0               ; Si no es 0, salta a DEC_DESDE_X0
                                     
                                     ; Si estamos en 00, ir a 23
0003d4 e003                          ldi temp, 3                     ; Carga 3 en 'temp' para establecer las unidades de horas a 3
0003d5 9300 0104                     sts hora_unidades, temp         ; Establece las unidades de horas a 3
0003d7 e012                          ldi temp2, 2                    ; Carga 2 en 'temp2' para establecer las decenas de horas a 2
0003d8 9310 0105                     sts hora_decenas, temp2         ; Establece las decenas de horas a 2
0003da 9508                          ret                              ; Retorna de la subrutina
                                     
                                 DEC_DESDE_X0:
                                     ; Si unidades = 0 y decenas > 0
0003db e009                          ldi temp, 9                     ; Carga 9 en 'temp' para establecer las unidades de horas a 9
0003dc 9300 0104                     sts hora_unidades, temp         ; Establece las unidades de horas a 9
0003de 951a                          dec temp2                       ; Decrementa el contador de decenas de horas
0003df 9310 0105                     sts hora_decenas, temp2         ; Guarda el nuevo valor de las decenas de horas
0003e1 9508                          ret                              ; Retorna de la subrutina
                                     
                                 DEC_HORA_UNIT:
0003e2 950a                          dec temp                        ; Decrementa el contador de unidades de horas
0003e3 9300 0104                     sts hora_unidades, temp         ; Guarda el nuevo valor de las unidades de horas
0003e5 9508                          ret                              ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; OBTENER_LIMITE_DIAS: Determina cuÃ¡ntos dÃ­as tiene el mes actual
                                 ;----------------------------------------------
                                 OBTENER_LIMITE_DIAS:
                                     ; Verifica quÃ© mes es para conocer su lÃ­mite de dÃ­as
                                     ; Resultado en digit
0003e6 9100 0109                     lds temp, mes_decenas          ; Carga el valor de las decenas del mes en 'temp'
0003e8 3000                          cpi temp, 0                    ; Compara 'temp' con 0
0003e9 f461                          brne CHECK_MESES_10_12        ; Si no es 0, salta a CHECK_MESES_10_12 (meses 10-12)
                                     
                                     ; Para meses del 1 al 9
0003ea 9100 0108                     lds temp, mes_unidades         ; Carga el valor de las unidades del mes en 'temp'
0003ec 3002                          cpi temp, 2                    ; Compara con 2 (Febrero)
0003ed f071                          breq ES_FEBRERO                ; Si es Febrero, salta a ES_FEBRERO
                                     
0003ee 3004                          cpi temp, 4                    ; Compara con 4 (Abril)
0003ef f071                          breq ES_MES_30                 ; Si es Abril, salta a ES_MES_30
                                     
0003f0 3006                          cpi temp, 6                    ; Compara con 6 (Junio)
0003f1 f061                          breq ES_MES_30                 ; Si es Junio, salta a ES_MES_30
                                     
0003f2 3009                          cpi temp, 9                    ; Compara con 9 (Septiembre)
0003f3 f051                          breq ES_MES_30                 ; Si es Septiembre, salta a ES_MES_30
                                     
                                     ; Meses de 31 dÃ­as (Enero, Marzo, Mayo, Julio, Agosto)
0003f4 e12f                          ldi digit, 31                  ; Establece el lÃ­mite de dÃ­as a 31
0003f5 9508                          ret                             ; Retorna de la subrutina
                                     
                                 CHECK_MESES_10_12:
0003f6 9100 0108                     lds temp, mes_unidades         ; Carga el valor de las unidades del mes en 'temp'
0003f8 3001                          cpi temp, 1                    ; Compara con 1 (Noviembre)
0003f9 f021                          breq ES_MES_30                 ; Si es Noviembre, salta a ES_MES_30
                                     
                                     ; Meses de 31 dÃ­as (Octubre y Diciembre)
0003fa e12f                          ldi digit, 31                  ; Establece el lÃ­mite de dÃ­as a 31
0003fb 9508                          ret                             ; Retorna de la subrutina
                                     
                                 ES_FEBRERO:
0003fc e12c                          ldi digit, 28                  ; Establece el lÃ­mite de dÃ­as a 28 (sin aÃ±os bisiestos)
0003fd 9508                          ret                             ; Retorna de la subrutina
                                     
                                 ES_MES_30:
0003fe e12e                          ldi digit, 30                  ; Establece el lÃ­mite de dÃ­as a 30
0003ff 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_DIAS_MANUAL: Incrementa dÃ­as manualmente (para configuraciÃ³n)
                                 ;----------------------------------------------
                                 INCREMENTAR_DIAS_MANUAL:
                                     ; Primero obtenemos el lÃ­mite de dÃ­as segÃºn el mes actual
000400 dfe5                          rcall OBTENER_LIMITE_DIAS      ; Llama a la subrutina para obtener el lÃ­mite de dÃ­as
                                     ; digit contiene ahora el lÃ­mite de dÃ­as (28, 30 o 31)
                                     
                                     ; Incrementa unidades de dÃ­a
000401 9100 0106                     lds temp, dia_unidades          ; Carga el valor actual de las unidades de dÃ­a en 'temp'
000403 9503                          inc temp                        ; Incrementa el contador de unidades de dÃ­a
000404 300a                          cpi temp, 10                    ; Compara 'temp' con 10
000405 f449                          brne CHECK_LIMITE_DIA_INC      ; Si no es 10, salta a CHECK_LIMITE_DIA_INC
                                     
                                     ; Si llegÃ³ a 10, resetear unidades e incrementar decenas
000406 e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las unidades de dÃ­a
000407 9300 0106                     sts dia_unidades, temp          ; Reinicia las unidades de dÃ­a
                                     
000409 9100 0107                     lds temp, dia_decenas           ; Carga el valor actual de las decenas de dÃ­a en 'temp'
00040b 9503                          inc temp                        ; Incrementa el contador de decenas de dÃ­a
00040c 9300 0107                     sts dia_decenas, temp           ; Guarda el nuevo valor de las decenas de dÃ­a
00040e c002                          rjmp CHECK_DIA_TOTAL_INC        ; Salta a CHECK_DIA_TOTAL_INC
                                     
                                 CHECK_LIMITE_DIA_INC:
00040f 9300 0106                     sts dia_unidades, temp          ; Guarda el nuevo valor de las unidades de dÃ­a
                                     
                                 CHECK_DIA_TOTAL_INC:
                                     ; Verificar si superamos el lÃ­mite del mes actual
000411 9100 0107                     lds temp, dia_decenas           ; Carga el valor de las decenas de dÃ­a en 'temp'
000413 e0ea                          ldi ZL, 10                      ; Carga 10 en ZL para la multiplicaciÃ³n
000414 9f0e                          mul temp, ZL                    ; Multiplica decenas por 10 (almacena en r0)
000415 9100 0106                     lds temp, dia_unidades          ; Carga el valor de las unidades de dÃ­a en 'temp'
000417 0e00                          add r0, temp                    ; Suma r0 (decenas * 10) con las unidades de dÃ­a
                                     
000418 1602                          cp r0, digit                    ; Compara con el lÃ­mite de dÃ­as
000419 f030                          brlo EXIT_INC_DIAS_MANUAL       ; Si no se ha superado el lÃ­mite, salir
                                     
                                     ; Si llegamos al lÃ­mite+1, volver al dÃ­a 1
00041a e001                          ldi temp, 1                     ; Carga 1 en 'temp' para reiniciar el dÃ­a
00041b 9300 0106                     sts dia_unidades, temp          ; Establece las unidades de dÃ­a a 1
00041d e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las decenas de dÃ­a
00041e 9300 0107                     sts dia_decenas, temp           ; Establece las decenas de dÃ­a a 0
                                     
                                 EXIT_INC_DIAS_MANUAL:
000420 9508                          ret                              ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; DECREMENTAR_DIAS_MANUAL: Decrementa dÃ­as manualmente (para configuraciÃ³n)
                                 ;----------------------------------------------
                                 DECREMENTAR_DIAS_MANUAL:
                                     ; Verificar si estamos en dÃ­a 01
000421 9100 0106                     lds temp, dia_unidades          ; Carga el valor actual de las unidades de dÃ­a en 'temp'
000423 3001                          cpi temp, 1                     ; Compara 'temp' con 1
000424 f4f1                          brne DEC_NO_ES_DIA_UNO         ; Si no es 1, salta a DEC_NO_ES_DIA_UNO
                                     
000425 9100 0107                     lds temp, dia_decenas           ; Carga el valor actual de las decenas de dÃ­a en 'temp'
000427 3000                          cpi temp, 0                     ; Compara 'temp' con 0
000428 f4d1                          brne DEC_NO_ES_DIA_UNO         ; Si no es 0, salta a DEC_NO_ES_DIA_UNO
                                     
                                     ; Si estamos en dÃ­a 01, ir al Ãºltimo dÃ­a del mes
000429 dfbc                          rcall OBTENER_LIMITE_DIAS      ; Llama a la subrutina para obtener el lÃ­mite de dÃ­as
                                     ; digit contiene ahora el lÃ­mite de dÃ­as
                                     
00042a 312e                          cpi digit, 30                   ; Compara el lÃ­mite de dÃ­as con 30
00042b f049                          breq SET_DIA_30                 ; Si es 30, salta a SET_DIA_30
00042c 312c                          cpi digit, 28                   ; Compara el lÃ­mite de dÃ­as con 28
00042d f071                          breq SET_DIA_28                 ; Si es 28, salta a SET_DIA_28
                                     
                                     ; Para meses de 31 dÃ­as
00042e e001                          ldi temp, 1                     ; Carga 1 en 'temp' para establecer el dÃ­a a 1
00042f 9300 0106                     sts dia_unidades, temp          ; Establece las unidades de dÃ­a a 1
000431 e003                          ldi temp, 3                     ; Carga 3 en 'temp' para establecer las decenas de dÃ­a a 3
000432 9300 0107                     sts dia_decenas, temp           ; Establece las decenas de dÃ­a a 3
000434 9508                          ret                              ; Retorna de la subrutina
                                     
                                 SET_DIA_30:
000435 e000                          ldi temp, 0                     ; Carga 0 en 'temp' para establecer las unidades de dÃ­a a 0
000436 9300 0106                     sts dia_unidades, temp          ; Establece las unidades de dÃ­a a 0
000438 e003                          ldi temp, 3                     ; Carga 3 en 'temp' para establecer las decenas de dÃ­a a 3
000439 9300 0107                     sts dia_decenas, temp           ; Establece las decenas de dÃ­a a 3
00043b 9508                          ret                              ; Retorna de la subrutina
                                     
                                 SET_DIA_28:
00043c e008                          ldi temp, 8                     ; Carga 8 en 'temp' para establecer las unidades de dÃ­a a 8
00043d 9300 0106                     sts dia_unidades, temp          ; Establece las unidades de dÃ­a a 8
00043f e002                          ldi temp, 2                     ; Carga 2 en 'temp' para establecer las decenas de dÃ­a a 2
000440 9300 0107                     sts dia_decenas, temp           ; Establece las decenas de dÃ­a a 2
000442 9508                          ret                              ; Retorna de la subrutina
                                     
                                 DEC_NO_ES_DIA_UNO:
                                     ; Decrementar normal
000443 9100 0106                     lds temp, dia_unidades          ; Carga el valor actual de las unidades de dÃ­a en 'temp'
000445 3000                          cpi temp, 0                     ; Compara 'temp' con 0
000446 f449                          brne DEC_DIA_UNIT               ; Si no es 0, salta a DEC_DIA_UNIT
                                     
                                     ; Si unidades = 0, poner 9 y decrementar decenas
000447 e009                          ldi temp, 9                     ; Carga 9 en 'temp' para establecer las unidades de dÃ­a a 9
000448 9300 0106                     sts dia_unidades, temp          ; Establece las unidades de dÃ­a a 9
                                     
00044a 9100 0107                     lds temp, dia_decenas           ; Carga el valor actual de las decenas de dÃ­a en 'temp'
00044c 950a                          dec temp                        ; Decrementa el contador de decenas de dÃ­a
00044d 9300 0107                     sts dia_decenas, temp           ; Guarda el nuevo valor de las decenas de dÃ­a
00044f 9508                          ret                              ; Retorna de la subrutina
                                     
                                 DEC_DIA_UNIT:
000450 950a                          dec temp                        ; Decrementa el contador de unidades de dÃ­a
000451 9300 0106                     sts dia_unidades, temp          ; Guarda el nuevo valor de las unidades de dÃ­a
000453 9508                          ret                              ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_MESES_MANUAL: Incrementa meses manualmente (para configuraciÃ³n)
                                 ;----------------------------------------------
                                 INCREMENTAR_MESES_MANUAL:
000454 9100 0108                     lds temp, mes_unidades          ; Carga el valor actual de las unidades del mes en 'temp'
000456 9503                          inc temp                        ; Incrementa el contador de unidades del mes
000457 300a                          cpi temp, 10                    ; Compara 'temp' con 10
000458 f4b1                          brne CHECK_LIMITE_MES_INC      ; Si no es 10, salta a CHECK_LIMITE_MES_INC
                                     
                                     ; Si llegÃ³ a 10, resetear unidades e incrementar decenas
000459 e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las unidades del mes
00045a 9300 0108                     sts mes_unidades, temp          ; Reinicia las unidades del mes
                                     
00045c 9100 0109                     lds temp, mes_decenas           ; Carga el valor actual de las decenas del mes en 'temp'
00045e 9503                          inc temp                        ; Incrementa el contador de decenas del mes
00045f 3001                          cpi temp, 1                     ; Compara 'temp' con 1 (diciembre)
000460 f459                          brne SAVE_MES_DEC_INC          ; Si no es 1, salta a SAVE_MES_DEC_INC
                                     
                                     ; Si es 1, verificar que no pasemos de 12 meses
000461 9110 0108                     lds temp2, mes_unidades         ; Carga el valor de las unidades del mes en 'temp2'
000463 3013                          cpi temp2, 3                    ; Compara con 3
000464 f038                          brlo SAVE_MES_DEC_INC           ; Si es menor que 3, salta a SAVE_MES_DEC_INC
                                     
                                     ; Si es mes 13 o mÃ¡s, volver a mes 01
000465 e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las decenas del mes
000466 9300 0109                     sts mes_decenas, temp           ; Establece las decenas del mes a 0
000468 e001                          ldi temp, 1                     ; Carga 1 en 'temp' para establecer las unidades del mes a 1
000469 9300 0108                     sts mes_unidades, temp          ; Establece las unidades del mes a 1
00046b c013                          rjmp AJUSTAR_DIA_POR_MES       ; Salta a AJUSTAR_DIA_POR_MES
                                     
                                 SAVE_MES_DEC_INC:
00046c 9300 0109                     sts mes_decenas, temp           ; Guarda el nuevo valor de las decenas del mes
00046e c010                          rjmp AJUSTAR_DIA_POR_MES       ; Salta a AJUSTAR_DIA_POR_MES
                                     
                                 CHECK_LIMITE_MES_INC:
00046f 9300 0108                     sts mes_unidades, temp          ; Guarda el nuevo valor de las unidades del mes
                                     
                                     ; Verificar si estamos en mes 13
000471 9100 0109                     lds temp, mes_decenas           ; Carga el valor actual de las decenas del mes en 'temp'
000473 3001                          cpi temp, 1                     ; Compara 'temp' con 1
000474 f451                          brne AJUSTAR_DIA_POR_MES       ; Si no es 1, salta a AJUSTAR_DIA_POR_MES
                                     
000475 9100 0108                     lds temp, mes_unidades          ; Carga el valor actual de las unidades del mes en 'temp'
000477 3003                          cpi temp, 3                     ; Compara 'temp' con 3
000478 f030                          brlo AJUSTAR_DIA_POR_MES       ; Si es menor que 3, salta a AJUSTAR_DIA_POR_MES
                                     
                                     ; Si es mes 13, volver a mes 01
000479 e001                          ldi temp, 1                     ; Carga 1 en 'temp' para establecer las unidades del mes a 1
00047a 9300 0108                     sts mes_unidades, temp          ; Establece las unidades del mes a 1
00047c e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las decenas del mes
00047d 9300 0109                     sts mes_decenas, temp           ; Establece las decenas del mes a 0
                                     
                                 AJUSTAR_DIA_POR_MES:
                                     ; Ajustar el dÃ­a si cambiamos a un mes con menos dÃ­as
00047f df66                          rcall OBTENER_LIMITE_DIAS      ; Llama a la subrutina para obtener el lÃ­mite de dÃ­as
                                     ; digit ahora tiene el lÃ­mite del nuevo mes
                                     
000480 9100 0107                     lds temp, dia_decenas           ; Carga el valor de las decenas de dÃ­a en 'temp'
000482 e0ea                          ldi ZL, 10                      ; Carga 10 en ZL para la multiplicaciÃ³n
000483 9f0e                          mul temp, ZL                    ; Multiplica decenas por 10 (almacena en r0)
000484 9100 0106                     lds temp, dia_unidades          ; Carga el valor de las unidades de dÃ­a en 'temp'
000486 0e00                          add r0, temp                    ; Suma r0 (decenas * 10) con las unidades de dÃ­a
                                     
000487 1602                          cp r0, digit                    ; Compara con el lÃ­mite de dÃ­as
000488 f0c0                          brlo EXIT_INC_MES_MANUAL       ; Si el dÃ­a actual es vÃ¡lido, no hacer nada
                                     
                                     ; Si el dÃ­a actual excede el lÃ­mite del nuevo mes, ajustar al Ãºltimo dÃ­a
000489 312e                          cpi digit, 30                   ; Compara con 30
00048a f049                          breq SET_ULTIMO_DIA_30         ; Si es 30, salta a SET_ULTIMO_DIA_30
00048b 312c                          cpi digit, 28                   ; Compara con 28
00048c f071                          breq SET_ULTIMO_DIA_28         ; Si es 28, salta a SET_ULTIMO_DIA_28
                                     
                                     ; Para meses de 31 dÃ­as
00048d e001                          ldi temp, 1                     ; Carga 1 en 'temp' para establecer las unidades de dÃ­a a 1
00048e 9300 0106                     sts dia_unidades, temp          ; Establece las unidades de dÃ­a a 1
000490 e003                          ldi temp, 3                     ; Carga 3 en 'temp
000491 9300 0107                     sts dia_decenas, temp           ; Guarda el nuevo valor de las decenas de dÃ­a en la variable 'dia_decenas'
000493 c00d                          rjmp EXIT_INC_MES_MANUAL		; Salta incondicionalmente a la etiqueta EXIT_INC_MES_MANUAL
                                 
                                 SET_ULTIMO_DIA_30:
000494 e000                          ldi temp, 0                    ; Carga 0 en 'temp' para establecer las unidades de dÃ­a a 0
000495 9300 0106                     sts dia_unidades, temp         ; Establece las unidades de dÃ­a a 0 (Ãºltimo dÃ­a del mes de 30 dÃ­as)
000497 e003                          ldi temp, 3                    ; Carga 3 en 'temp' para establecer las decenas de dÃ­a a 3
000498 9300 0107                     sts dia_decenas, temp          ; Establece las decenas de dÃ­a a 3 (30)
00049a c006                          rjmp EXIT_INC_MES_MANUAL       ; Salta incondicionalmente a la etiqueta EXIT_INC_MES_MANUAL
                                 
                                 SET_ULTIMO_DIA_28:
00049b e008                          ldi temp, 8                    ; Carga 8 en 'temp' para establecer las unidades de dÃ­a a 8 (Ãºltimo dÃ­a de febrero)
00049c 9300 0106                     sts dia_unidades, temp         ; Establece las unidades de dÃ­a a 8
00049e e002                          ldi temp, 2                    ; Carga 2 en 'temp' para establecer las decenas de dÃ­a a 2
00049f 9300 0107                     sts dia_decenas, temp          ; Establece las decenas de dÃ­a a 2 (28)
                                 
                                 EXIT_INC_MES_MANUAL:
0004a1 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; DECREMENTAR_MESES_MANUAL: Decrementa meses manualmente (para configuraciÃ³n)
                                 ;----------------------------------------------
                                 DECREMENTAR_MESES_MANUAL:
0004a2 9100 0108                     lds temp, mes_unidades          ; Carga el valor actual de las unidades del mes en 'temp'
0004a4 3001                          cpi temp, 1                     ; Compara 'temp' con 1
0004a5 f459                          brne DEC_MES_NORMAL             ; Si no es 1, salta a DEC_MES_NORMAL
                                     
0004a6 9100 0109                     lds temp, mes_decenas           ; Carga el valor actual de las decenas del mes en 'temp'
0004a8 3000                          cpi temp, 0                     ; Compara 'temp' con 0
0004a9 f439                          brne DEC_MES_NORMAL             ; Si no es 0, salta a DEC_MES_NORMAL
                                     
                                     ; Si estamos en mes 01, ir a mes 12
0004aa e002                          ldi temp, 2                     ; Carga 2 en 'temp' para establecer las unidades del mes a 2 (Febrero)
0004ab 9300 0108                     sts mes_unidades, temp          ; Establece las unidades del mes a 2
0004ad e001                          ldi temp, 1                     ; Carga 1 en 'temp' para establecer las decenas del mes a 1 (Enero)
0004ae 9300 0109                     sts mes_decenas, temp           ; Establece las decenas del mes a 1
0004b0 c010                          rjmp AJUSTAR_DIA_POR_MES_DEC    ; Salta a AJUSTAR_DIA_POR_MES_DEC para ajustar el dÃ­a
                                 
                                 DEC_MES_NORMAL:
                                     ; Decrementar normal
0004b1 9100 0108                     lds temp, mes_unidades          ; Carga el valor actual de las unidades del mes en 'temp'
0004b3 3000                          cpi temp, 0                     ; Compara 'temp' con 0
0004b4 f449                          brne DEC_MES_UNIT               ; Si no es 0, salta a DEC_MES_UNIT
                                     
                                     ; Si unidades = 0, poner 9 y decrementar decenas
0004b5 e009                          ldi temp, 9                     ; Carga 9 en 'temp' para establecer las unidades del mes a 9
0004b6 9300 0108                     sts mes_unidades, temp          ; Establece las unidades del mes a 9
                                     
0004b8 9100 0109                     lds temp, mes_decenas           ; Carga el valor actual de las decenas del mes en 'temp'
0004ba 950a                          dec temp                        ; Decrementa el contador de decenas del mes
0004bb 9300 0109                     sts mes_decenas, temp           ; Guarda el nuevo valor de las decenas del mes
0004bd c003                          rjmp AJUSTAR_DIA_POR_MES_DEC    ; Salta a AJUSTAR_DIA_POR_MES_DEC para ajustar el dÃ­a
                                     
                                 DEC_MES_UNIT:
0004be 950a                          dec temp                        ; Decrementa el contador de unidades del mes
0004bf 9300 0108                     sts mes_unidades, temp          ; Guarda el nuevo valor de las unidades del mes
                                     
                                 AJUSTAR_DIA_POR_MES_DEC:
                                     ; Igual que en AJUSTAR_DIA_POR_MES
0004c1 df24                          rcall OBTENER_LIMITE_DIAS      ; Llama a la subrutina para obtener el lÃ­mite de dÃ­as del mes actual
                                     
0004c2 9100 0107                     lds temp, dia_decenas           ; Carga el valor de las decenas de dÃ­a en 'temp'
0004c4 e0ea                          ldi ZL, 10                      ; Carga 10 en ZL para la multiplicaciÃ³n
0004c5 9f0e                          mul temp, ZL                    ; Multiplica decenas por 10 (almacena en r0)
0004c6 9100 0106                     lds temp, dia_unidades          ; Carga el valor de las unidades de dÃ­a en 'temp'
0004c8 0e00                          add r0, temp                    ; Suma r0 (decenas * 10) con las unidades de dÃ­a
                                     
0004c9 1602                          cp r0, digit                    ; Compara con el lÃ­mite de dÃ­as
0004ca f0c8                          brlo EXIT_DEC_MES_MANUAL       ; Si el dÃ­a actual es vÃ¡lido, no hacer nada
                                     
                                     ; Si el dÃ­a actual excede el lÃ­mite del nuevo mes, ajustar al Ãºltimo dÃ­a
0004cb 2f02                          mov temp, digit                 ; Carga el lÃ­mite de dÃ­as en 'temp'
0004cc 310c                          cpi temp, 28                    ; Compara con 28
0004cd f081                          breq SET_DIA_28_DEC             ; Si es 28, salta a SET_DIA_28_DEC
0004ce 310e                          cpi temp, 30                    ; Compara con 30
0004cf f039                          breq SET_DIA_30_DEC             ; Si es 30, salta a SET_DIA_30_DEC
                                     
                                     ; Para meses de 31 dÃ­as
0004d0 e001                          ldi temp, 1                     ; Carga 1 en 'temp' para establecer las unidades de dÃ­a a 1
0004d1 9300 0106                     sts dia_unidades, temp          ; Establece las unidades de dÃ­a a 1
0004d3 e003                          ldi temp, 3                     ; Carga 3 en 'temp' para establecer las decenas de dÃ­a a 3
0004d4 9300 0107                     sts dia_decenas, temp           ; Guarda el nuevo valor de las decenas de dÃ­a en la variable 'dia_decenas'
0004d6 c00d                          rjmp EXIT_DEC_MES_MANUAL        ; Salta incondicionalmente a la etiqueta EXIT_DEC_MES_MANUAL
                                 
                                 SET_DIA_30_DEC:
0004d7 e000                          ldi temp, 0                     ; Carga 0 en 'temp' para establecer las unidades de dÃ­a a 0
0004d8 9300 0106                     sts dia_unidades, temp          ; Establece las unidades de dÃ­a a 0 (Ãºltimo dÃ­a del mes de 30 dÃ­as)
0004da e003                          ldi temp, 3                     ; Carga 3 en 'temp' para establecer las decenas de dÃ­a a 3 (30)
0004db 9300 0107                     sts dia_decenas, temp           ; Establece las decenas de dÃ­a a 3
0004dd c006                          rjmp EXIT_DEC_MES_MANUAL        ; Salta incondicionalmente a la etiqueta EXIT_DEC_MES_MANUAL
                                 
                                 SET_DIA_28_DEC:
0004de e008                          ldi temp, 8                     ; Carga 8 en 'temp' para establecer las unidades de dÃ­a a 8 (Ãºltimo dÃ­a de febrero)
0004df 9300 0106                     sts dia_unidades, temp          ; Establece las unidades de dÃ­a a 8
0004e1 e002                          ldi temp, 2                     ; Carga 2 en 'temp' para establecer las decenas de dÃ­a a 2
0004e2 9300 0107                     sts dia_decenas, temp           ; Establece las decenas de dÃ­a a 2 (28)
                                 
                                 EXIT_DEC_MES_MANUAL:
0004e4 9508                          ret                              ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_HORAS_ALARMA: Incrementa horas de alarma manualmente
                                 ;----------------------------------------------
                                 INCREMENTAR_HORAS_ALARMA:
0004e5 e001                          ldi temp, 1                    ; Carga 1 en 'temp' para indicar que la alarma estÃ¡ activa
0004e6 9300 0115                     sts alarma_activa, temp        ; Establece el estado de la alarma como activa
0004e8 9100 0111                     lds temp, alarma_hora_unidades ; Carga el valor actual de las unidades de la hora de la alarma en 'temp'
0004ea 9503                          inc temp                       ; Incrementa el contador de unidades de la hora de la alarma
0004eb 300a                          cpi temp, 10                   ; Compara 'temp' con 10
0004ec f461                          brne CHECK_MAX_HORA_ALARM_INC  ; Si no es 10, salta a CHECK_MAX_HORA_ALARM_INC
                                     
                                     ; Si llegÃ³ a 10, resetear unidades e incrementar decenas
0004ed e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar las unidades de la hora de la alarma
0004ee 9300 0111                     sts alarma_hora_unidades, temp  ; Establece las unidades de la hora de la alarma a 0
                                     
0004f0 9100 0112                     lds temp, alarma_hora_decenas  ; Carga el valor actual de las decenas de la hora de la alarma en 'temp'
0004f2 9503                          inc temp                       ; Incrementa el contador de decenas de la hora de la alarma
0004f3 3003                          cpi temp, 3                    ; MÃ¡ximo 2 para formato 24h
0004f4 f409                          brne SAVE_HORA_ALARM_DEC_INC   ; Si no es 3, salta a SAVE_HORA_ALARM_DEC_INC
                                     
                                     ; Si llegÃ³ a 3, resetear decenas
0004f5 e000                          ldi temp, 0                    ; Carga 0 en 'temp' para reiniciar las decenas de la hora de la alarma
                                     
                                 SAVE_HORA_ALARM_DEC_INC:
0004f6 9300 0112                     sts alarma_hora_decenas, temp  ; Guarda el nuevo valor de las decenas de la hora de la alarma
0004f8 9508                          ret                             ; Retorna de la subrutina
                                     
                                 CHECK_MAX_HORA_ALARM_INC:
                                     ; Verificar si superamos 23 horas
0004f9 9110 0112                     lds temp2, alarma_hora_decenas  ; Carga el valor actual de las decenas de la hora de la alarma en 'temp2'
0004fb 3012                          cpi temp2, 2                    ; Compara 'temp2' con 2
0004fc f441                          brne SAVE_HORA_ALARM_UNIT_INC   ; Si no es 2, salta a SAVE_HORA_ALARM_UNIT_INC
                                     
                                     ; Si decenas es 2, unidades no puede ser mayor que 3
0004fd 3004                          cpi temp, 4                     ; Compara 'temp' con 4
0004fe f030                          brlo SAVE_HORA_ALARM_UNIT_INC   ; Si es menor que 4, salta a SAVE_HORA_ALARM_UNIT_INC
                                     
                                     ; Si llegÃ³ a 24, resetear a 00
0004ff e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las unidades de la hora de la alarma
000500 9300 0111                     sts alarma_hora_unidades, temp  ; Establece las unidades de la hora de la alarma a 0
000502 9300 0112                     sts alarma_hora_decenas, temp   ; Establece las decenas de la hora de la alarma a 0
000504 9508                          ret                             ; Retorna de la subrutina
                                     
                                 SAVE_HORA_ALARM_UNIT_INC:
000505 9300 0111                     sts alarma_hora_unidades, temp  ; Guarda el nuevo valor de las unidades de la hora de la alarma
000507 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; DECREMENTAR_HORAS_ALARMA: Decrementa horas de alarma manualmente
                                 ;----------------------------------------------
                                 DECREMENTAR_HORAS_ALARMA:
000508 e001                          ldi temp, 1                    ; Carga 1 en 'temp' para indicar que la alarma estÃ¡ activa
000509 9300 0115                     sts alarma_activa, temp        ; Establece el estado de la alarma como activa
00050b 9100 0111                     lds temp, alarma_hora_unidades ; Carga el valor actual de las unidades de la hora de la alarma en 'temp'
00050d 3000                          cpi temp, 0                    ; Compara 'temp' con 0
00050e f491                          brne DEC_HORA_ALARM_UNIT       ; Si no es 0, salta a DEC_HORA_ALARM_UNIT
                                     
                                     ; Si unidades era 0
00050f 9110 0112                     lds temp2, alarma_hora_decenas ; Carga el valor actual de las decenas de la hora de la alarma en 'temp2'
000511 3010                          cpi temp2, 0                   ; Compara 'temp2' con 0
000512 f439                          brne DEC_DESDE_X0_ALARM        ; Si no es 0, salta a DEC_DESDE_X0_ALARM
                                     
                                     ; Si estamos en 00, ir a 23
000513 e003                          ldi temp, 3                    ; Carga 3 en 'temp' para establecer las unidades de la hora a 3
000514 9300 0111                     sts alarma_hora_unidades, temp  ; Establece las unidades de la hora de la alarma a 3
000516 e012                          ldi temp2, 2                   ; Carga 2 en 'temp2' para establecer las decenas de la hora a 2
000517 9310 0112                     sts alarma_hora_decenas, temp2  ; Establece las decenas de la hora de la alarma a 2
000519 9508                          ret                             ; Retorna de la subrutina
                                     
                                 DEC_DESDE_X0_ALARM:
                                     ; Si unidades = 0 y decenas > 0
00051a e009                          ldi temp, 9                     ; Carga 9 en 'temp' para establecer las unidades de la hora a 9
00051b 9300 0111                     sts alarma_hora_unidades, temp  ; Guarda el nuevo valor de las unidades de la hora de la alarma en 'alarma_hora_unidades'
00051d 951a                          dec temp2                       ; Decrementa el contador de decenas de la hora de la alarma
00051e 9310 0112                     sts alarma_hora_decenas, temp2  ; Guarda el nuevo valor de las decenas de la hora de la alarma
000520 9508                          ret                             ; Retorna de la subrutina
                                     
                                 DEC_HORA_ALARM_UNIT:
000521 950a                          dec temp                        ; Decrementa el contador de unidades de la hora de la alarma
000522 9300 0111                     sts alarma_hora_unidades, temp  ; Guarda el nuevo valor de las unidades de la hora de la alarma
000524 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; INCREMENTAR_MINUTOS_ALARMA: Incrementa minutos de alarma manualmente
                                 ;----------------------------------------------
                                 INCREMENTAR_MINUTOS_ALARMA:
000525 e001                          ldi temp, 1                    ; Carga 1 en 'temp' para indicar que la alarma estÃ¡ activa
000526 9300 0115                     sts alarma_activa, temp        ; Establece el estado de la alarma como activa
000528 9100 0113                     lds temp, alarma_min_unidades   ; Carga el valor actual de las unidades de minutos de la alarma en 'temp'
00052a 9503                          inc temp                       ; Incrementa el contador de unidades de minutos de la alarma
00052b 300a                          cpi temp, 10                    ; Compara 'temp' con 10
00052c f461                          brne SAVE_MIN_ALARM_UNIT_INC    ; Si no es 10, salta a SAVE_MIN_ALARM_UNIT_INC
                                     
                                     ; Si llegÃ³ a 10, resetear unidades e incrementar decenas
00052d e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las unidades de minutos de la alarma
00052e 9300 0113                     sts alarma_min_unidades, temp    ; Establece las unidades de minutos de la alarma a 0
                                     
000530 9100 0114                     lds temp, alarma_min_decenas     ; Carga el valor actual de las decenas de minutos de la alarma en 'temp'
000532 9503                          inc temp                        ; Incrementa el contador de decenas de minutos de la alarma
000533 3006                          cpi temp, 6                     ; Compara 'temp' con 6
000534 f409                          brne SAVE_MIN_ALARM_DEC_INC     ; Si no es 6, salta a SAVE_MIN_ALARM_DEC_INC
                                     
                                     ; Si llegÃ³ a 6, resetear decenas
000535 e000                          ldi temp, 0                     ; Carga 0 en 'temp' para reiniciar las decenas de minutos de la alarma
                                     
                                 SAVE_MIN_ALARM_DEC_INC:
000536 9300 0114                     sts alarma_min_decenas, temp    ; Guarda el nuevo valor de las decenas de minutos de la alarma
000538 9508                          ret                             ; Retorna de la subrutina
                                     
                                 SAVE_MIN_ALARM_UNIT_INC:
000539 9300 0113                     sts alarma_min_unidades, temp    ; Guarda el nuevo valor de las unidades de minutos de la alarma
00053b 9508                          ret                             ; Retorna de la subrutina
                                 
                                 ;----------------------------------------------
                                 ; DECREMENTAR_MINUTOS_ALARMA: Decrementa minutos de alarma manualmente
                                 ;----------------------------------------------
                                 DECREMENTAR_MINUTOS_ALARMA:
00053c e001                          ldi temp, 1                    ; Carga 1 en 'temp' para indicar que la alarma estÃ¡ activa
00053d 9300 0115                     sts alarma_activa, temp        ; Establece el estado de la alarma como activa
00053f 9100 0113                     lds temp, alarma_min_unidades   ; Carga el valor actual de las unidades de minutos de la alarma en 'temp'
000541 3000                          cpi temp, 0                    ; Compara 'temp' con 0
000542 f461                          brne DEC_MIN_ALARM_UNIT        ; Si no es 0, salta a DEC_MIN_ALARM_UNIT
                                     
                                     ; Si era 0, poner a 9 y decrementar decenas
000543 e009                          ldi temp, 9                    ; Carga 9 en 'temp' para establecer las unidades de minutos de la alarma a 9
000544 9300 0113                     sts alarma_min_unidades, temp   ; Establece las unidades de minutos de la alarma a 9
                                     
000546 9100 0114                     lds temp, alarma_min_decenas    ; Carga el valor actual de las decenas de minutos de la alarma en 'temp'
000548 3000                          cpi temp, 0                    ; Compara 'temp' con 0
000549 f409                          brne DEC_MIN_ALARM_DEC         ; Si no es 0, salta a DEC_MIN_ALARM_DEC
                                     
                                     ; Si decenas era 0, poner a 5
00054a e006                          ldi temp, 6                    ; Carga 6 en 'temp' para establecer las decenas de minutos de la alarma a 6
                                     
                                 DEC_MIN_ALARM_DEC:
00054b 950a                          dec temp                       ; Decrementa el contador de decenas de minutos de la alarma
00054c 9300 0114                     sts alarma_min_decenas, temp    ; Guarda el nuevo valor de las decenas de minutos de la alarma
00054e 9508                          ret                             ; Retorna de la subrutina
                                     
                                 DEC_MIN_ALARM_UNIT:
00054f 950a                          dec temp                       ; Decrementa el contador de unidades de minutos de la alarma
000550 9300 0113                     sts alarma_min_unidades, temp    ; Guarda el nuevo valor de las unidades de minutos de la alarma
000552 9508                          ret                             ; Retorna de la subrutina
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328PB" register use summary:
x  :   0 y  :   0 z  :   1 r0 :   6 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 610 r17:  44 r18:  35 r19:  33 r20:   3 
r21:   0 r22:   0 r23:   0 r24:   0 r25:   0 r26:   0 r27:   0 r28:   0 
r29:   0 r30:  10 r31:   4 
Registers used: 9 out of 35 (25.7%)

"ATmega328PB" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   4 adiw  :   0 and   :   0 
andi  :   7 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   1 brcs  :   0 break :   0 breq  :  48 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   8 brlt  :   0 brmi  :   0 
brne  :  92 brpl  :   0 brsh  :   1 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   2 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   0 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   9 cpc   :   0 
cpi   : 139 cpse  :   0 dec   :  13 eor   :   5 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  17 inc   :  26 jmp   :   0 
ld    :   0 ldd   :   0 ldi   : 145 lds   : 149 lpm   :   2 lsl   :   0 
lsr   :   0 mov   :   3 movw  :   0 mul   :   3 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   2 ori   :   2 out   :  18 pop   :   8 
push  :   8 rcall :  25 ret   :  65 reti  :   2 rjmp  :  63 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :   2 sbic  :   0 sbis  :   0 
sbiw  :   0 sbr   :   0 sbrc  :  10 sbrs  :   0 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 sts   : 150 
sub   :   0 subi  :   0 swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 32 out of 113 (28.3%)

"ATmega328PB" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000aa6   2656     10   2666   32768   8.1%
[.dseg] 0x000100 0x000119      0     25     25    2048   1.2%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
